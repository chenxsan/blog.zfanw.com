export default{"root":"../../..","dest":"_site","clean":true,"builtAt":1548079427676,"cache":{"themeManifest":{"404.css":"404.2b7e64c3d01ed6e20db8.css","404.js":"404.c97c0ff34f936a2d27c2.js","category.css":"category.7c78ded7cb0608e4923b.css","category.js":"category.3c09cd3613ceb6bd4ece.js","index.css":"index.994fdb6bf8f090442b0b.css","index.js":"index.e3eac8f1859b48921f65.js","page.css":"page.77a1cccc4dd1fd71010b.css","page.js":"page.bb2c087efaad74822262.js","post.css":"post.eae32687c2753f8f3188.css","post.js":"post.0ad2999e07c7c412c768.js","tag.css":"tag.7c78ded7cb0608e4923b.css","tag.js":"tag.2f674ef64a9fa1f7cfb2.js"},"clientJsManifest":{"client.js":"client.5dccbf22717a94b1d2ff.js"},"files":["/node-js-pass-arguments/","/parcel-bundler-tutorial/","/phoenix-framework-conn-test-recycling/","/how-i-found-a-remote-job/","/reactjs-code-splitting-lazy-load/","/replace-apache-with-caddy/","/how-to-mock-require-resolve-under-jest/","/nw-js-webpack-react/","/firebase-hosting-static-site/","/webpack-command-webpack-cli/","/javascript-undefined/","/how-to-write-static-site-generator/","/jsxstyle/","/telegram-outage-scam-bitcoin/","/adventures-in-rt-mart/","/react-js-cors/","/fzf-vim-usage/","/macos-apache/","/chrome-65-introduce-seo-audit/","/install-erlang-on-centos/","/centos-postgresql-command/","/move-wordpress-to-hugo/","/react-js-server-render/","/about-translation/","/babel-js/","/chrome-devtools-memory-profiling/","/webpack-tutorial/","/privoxy-proxy-share/","/ios-safari-click-not-working/","/sftp/","/privoxy-failed-problem/","/github-pages-custom-domain/","/srcset-and-sizes/","/privoxy-tutorial/","/best-practice-contribute-on-github/","/difference-between-dependencies-and-devdependencies/","/jquery-custom-event/","/on-interviewing-front-end-engineers/","/twitter-bootstrap-affix-js/","/css-architecture/","/markdown-and-table/","/raphael-js-tutorial/","/modernizr/","/css-triangle/","/firefox-22-new-cookies-policy/","/firefox-19/","/block-webpage-ad-with-privoxy/","/jquery-dynamic-insert-element-bind-event/","/javascript-match-all-strings/","/google-search-url-parameters/","/a-tale-of-east-asian-history-british-loan-sharks-and-a-russian-hacker/","/install-software-on-ubuntu/","/mosh/","/firefox-os/","/firefox-13/","/zencoding-vim-tutorial-chinese/","/firefox-new-ui-more-uniform/","/wordpress-drop-ie6-support/","/google-bing-yahoo-schema-org/","/vimperator-introduction/","/about/","/read/","/","/page2/","/page3/","/page4/","/page5/","/page6/","/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/","/topics/%E7%BF%BB%E8%AF%91/","/topics/babeljs/","/topics/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/","/topics/%E6%95%99%E7%A8%8B/","/topics/git/","/topics/github/","/topics/postgresql/","/topics/chrome/","/topics/%E6%96%B0%E9%97%BB/","/topics/javascript/","/topics/css/","/topics/npm/","/topics/vim/","/topics/zencodingvim/","/topics/emmetvim/","/topics/firebase/","/topics/firefox/","/topics/firefox-os/","/topics/google/","/topics/centos/","/topics/erlang/","/topics/ubuntu/","/topics/safari/","/topics/jest/","/topics/jquery/","/topics/css-in-js/","/topics/markdown/","/topics/modernizr/","/topics/mosh/","/topics/ssh/","/topics/nodejs/","/topics/reactjs/","/topics/webpack/","/topics/nwjs/","/topics/parcel/","/topics/phoenix/","/topics/privoxy/","/topics/raphaeljs/","/topics/sftp/","/topics/%E8%8B%A6%E9%97%B7%E7%9A%84%E8%B1%A1%E5%BE%81/","/topics/bootstrap/","/topics/vimperator/","/topics/wordpress/","/topics/caddy/","/404.html"],"layoutHash":["010121567c37c4bda18a240a9bec2d17","36079a15478b854a46db858811ca5c14"],"okmarvinConfig":{"markdown":{"toc":{"title":"目录"},"loadLanguages":["bash","elixir"]}},"siteConfig":{"title":"陈三","description":"记录人、事与代码","url":"https://blog.zfanw.com","author":"陈三","lang":"zh","theme":"@okmarvin/january","themeColor":"#ffd54f","toc":true,"permalink":"/:dir/:filename","rss":true,"favicon":"/static/img/favicon.ico","layoutHierarchy":{"post.js":["post.js","single.js","singular.js","index.js"],"page.js":["page.js","singular.js","index.js"],"index.js":["index.js"],"tag.js":["tag.js","archive.js","index.js"],"category.js":["category.js","archive.js","index.js"],"author.js":["author.js","archive.js","index.js"],"404.js":["404.js","index.js"]},"github":"chenxsan","twitter":"saturnake","google_analytics":"UA-19839258-14","paginate":10,"logo":"/static/img/logo.svg","menu":[{"text":"Home","permalink":"/"},{"text":"看书","permalink":"/read/"},{"text":"关于","permalink":"/about/"}]},"builtAt":1548074975873},"okmarvinConfig":{},"siteConfig":{"title":"陈三","description":"记录人、事与代码","url":"https://blog.zfanw.com","author":"陈三","lang":"zh","theme":"@okmarvin/january","themeColor":"#ffd54f","toc":true,"permalink":"/:dir/:filename","rss":true,"favicon":"/static/img/favicon.ico","layoutHierarchy":{"post.js":["post.js","single.js","singular.js","index.js"],"page.js":["page.js","singular.js","index.js"],"index.js":["index.js"],"tag.js":["tag.js","archive.js","index.js"],"category.js":["category.js","archive.js","index.js"],"author.js":["author.js","archive.js","index.js"],"404.js":["404.js","index.js"]},"github":"chenxsan","twitter":"saturnake","google_analytics":"UA-19839258-14","paginate":10,"logo":"/static/img/logo.svg","menu":[{"text":"Home","permalink":"/"},{"text":"看书","permalink":"/read/"},{"text":"关于","permalink":"/about/"}]},"fileAssets":["_pages/about/samchen.jpg","_posts/chrome 65 引入 seo audit/chrome-65-introduce-seo-audit.gif","_posts/Chrome 开发者工具分析内存使用情况/chrome-devtools-memory.png","_posts/Chrome 开发者工具分析内存使用情况/chrome-task-manager.png","_posts/Chrome 开发者工具分析内存使用情况/open-chrome-task-manager.png","_posts/css 三角形/css-triangle.mp4","_posts/Emmet.vim 教程/balance-tag-inward.mp4","_posts/firefox-os/robhawkes_cc-by-sa.jpg","_posts/github-pages-custom-domain/github-pages-custom-domain.png","_posts/macOS apache 配置/sites-folder.png","_posts/markdown-and-table/d921da7afba1f46e74e1cb2519ac1ba9.1e5f397d58cb14b61081.js","_posts/markdown-and-table/index.47462bd74e73d6108437.js","_posts/markdown-and-table/index.a23c5f6d0d70a5ff133ffe88447182db.css","_posts/markdown-and-table/runtime.f3f57d977d79f5fe68f6.js","_posts/srcset and sizes/barf.png","_posts/srcset and sizes/declarative.png","_posts/srcset and sizes/easypeas.png","_posts/srcset and sizes/empty-can.png","_posts/srcset and sizes/gulp.png","_posts/srcset and sizes/hammering.png","_posts/srcset and sizes/lightning.png","_posts/srcset and sizes/measuring-hole.png","_posts/srcset and sizes/measuring-image.png","_posts/srcset and sizes/media-queries.png","_posts/srcset and sizes/men-in-black.png","_posts/srcset and sizes/oops-720.mp4","_posts/srcset and sizes/oops-720.ogv","_posts/srcset and sizes/rainbow.png","_posts/srcset and sizes/study-up.png","_posts/srcset and sizes/yay-peas.png","_posts/telegram-scam-bitcoin/another-scam.png","_posts/telegram-scam-bitcoin/durov.png","_posts/telegram-scam-bitcoin/fake-durov.png","_posts/telegram-scam-bitcoin/it-is-hacked.png","_posts/telegram-scam-bitcoin/letsencrypt.jpg","_posts/telegram-scam-bitcoin/massive-overheating-telegram.png","_posts/telegram-scam-bitcoin/scam-site.png","_posts/telegram-scam-bitcoin/telegram-outage.png","_posts/telegram-scam-bitcoin/twitter-account.png","_posts/telegram-scam-bitcoin/wow-bitcoin.png","_posts/webpack 教程/debug-webpack-configuration.mp4","_posts/webpack 教程/demo/17f86d1c4bf821d9b9e8bfb0ec35bc8d.jpg","_posts/webpack 教程/demo/index.html","_posts/webpack 教程/demo/main.js","_posts/从 WordPress 到 Hugo/babel-6-comment.png","_posts/从 WordPress 到 Hugo/elixir-phoenix-framework-comment.png","_posts/我在大润发的一次遭遇/rt-mart-01.jpg","_posts/我在大润发的一次遭遇/rt-mart-02.JPG","_posts/我在大润发的一次遭遇/rt-mart-03.JPG","_posts/我在大润发的一次遭遇/rt-mart-04.jpeg","_posts/我在大润发的一次遭遇/rt-mart-05.jpeg","_posts/我在大润发的一次遭遇/rt-mart-06.jpeg","_posts/我在大润发的一次遭遇/rt-mart-07.jpeg","_posts/我在大润发的一次遭遇/rt-mart-08.JPG","_posts/我在大润发的一次遭遇/rt-mart-09.jpeg"],"clientJsManifest":{"client.js":"client.5dccbf22717a94b1d2ff.js"},"themeManifest":{"404.css":"404.2b7e64c3d01ed6e20db8.css","404.js":"404.c97c0ff34f936a2d27c2.js","category.css":"category.7c78ded7cb0608e4923b.css","category.js":"category.3c09cd3613ceb6bd4ece.js","index.css":"index.994fdb6bf8f090442b0b.css","index.js":"index.e3eac8f1859b48921f65.js","page.css":"page.77a1cccc4dd1fd71010b.css","page.js":"page.bb2c087efaad74822262.js","post.css":"post.eae32687c2753f8f3188.css","post.js":"post.0ad2999e07c7c412c768.js","tag.css":"tag.7c78ded7cb0608e4923b.css","tag.js":"tag.2f674ef64a9fa1f7cfb2.js"},"files":[{"filePath":"_pages/about/about.md","title":"关于","author":"陈三","date":"2009-12-29T09:09:34.000Z","permalink":"/about/","toc":false,"content":"\n如你所见，这是一个博客，记录一些转瞬即逝的人、事与代码。\n\n## 作者\n\n前端开发，目前[从事远程工作](/how-i-found-a-remote-job/)。\n\n<img src='./samchen.jpg' width='300' alt='陈三' />\n\n## 内容\n\n1. 职业相关的技术，包括 HTML、CSS、JavaScript、React.js、Node.js 等\n2. 业余时间学习的 Elixir、PhoenixFramework 技术\n\n### 联系我\n\n如果你有发现内容错误、失效等问题，欢迎给我发送邮件 <span id='email'></span>。\n\n## 博客修订记录\n\n* 2013.07.30 根据 BootStrap 3 对博客做修改。\n* 2013.08.04 Script 现由 LABjs 管理\n* 2014.01.01 去掉评论功能\n* 2014.03.22 加上评论，希望它们能对内容有所扩展、补充\n* 2014.11.01 修了一个移动端上链接无法点击的 bug，因为只设定 .col-lg-xx 类\n* 2015.04.17 关闭评论\n* 2015.04.30 基于 Google Material Design 改版，移除 BootStrap 样式\n* 2015.05.15 移除 CDN 上的整个 bootstrap.js，仅取用 affix.js 与 scrollspy.js 代码\n* 2015.06.10 移除汉堡包菜单，换成左侧可见的全局菜单，移动端上将全局菜单固定定位到屏幕底部\n* 2015.09.04 转 HTTPS\n* 2016.07.25 从 WordPress 迁移到 Hugo\n* 2017.09.14 从 Hugo 迁移到 [OkMarvin](https://github.com/OkMarvin)\n\n<script>\n  document.getElementById('email').textContent = 'chenxsan' + '@' + 'gmail.com'\n</script>","isEmpty":false,"excerpt":"","stats":{"ctimeMs":1548079427564.686},"description":"","datePublished":1262077774000,"dateModified":1262077774000,"template":"page.js"},{"filePath":"_pages/read.md","title":"看书","date":"2013-01-28T14:35:31.000Z","permalink":"/read/","content":"{:toc}\n\n如果光算借书量的话，我在某市图书馆大概也能排上前几名，一如大学时代。不过真正都看完的却属少数，也一如大学时代。法布尔的一本节译《昆虫记》我借了不下五回，却连第六篇都看不完，一直在屎克郞那章徘徊，又好像身边几本日语入门，我愣是把前几章烂熟了，可永远也只会那几章。\n\n不过谢天谢地，总算有看完的一些。\n\n| 时间       | 书名                                     | 作者                                  |\n| ---------- | ---------------------------------------- | ------------------------------------- |\n| 2013.1.27  | 无中生有                                 | 莎士比亚                              |\n| 2013.1.28  | 道连·格雷的画像                          | 王尔德                                |\n| 2013.2.9   | 人类思想史（冲击权威：从阿奎那到杰斐逊） | 彼得·沃森                             |\n| 2013.2.23  | 宽容                                     | 房龙                                  |\n| 2013.2.25  | 第十二夜                                 | 莎士比亚                              |\n| 2013.2.27  | 奥赛罗                                   | 莎士比亚                              |\n| 2013.4.1   | 十字军骑士                               | 显克维奇                              |\n| 2013.4.5   | 哈姆莱特                                 | 莎士比亚                              |\n| 2013.4.21  | 如果在冬夜，一个旅人                     | 卡尔维诺                              |\n| 2013.4.25  | 你往何处去                               | 显克维奇                              |\n| 2013.5.30  | 百年孤独                                 | 加西亚·马尔克斯                       |\n| 2013.6.12  | 雪国                                     | 川端康成                              |\n| 2013.6.30  | 古都                                     | 川端康成                              |\n| 2013.7.4   | 千纸鹤                                   | 川端康成                              |\n| 2013.8.18  | 墨攻                                     | 酒见贤一                              |\n| 2013.8.31  | 朗读者                                   | 本哈德·施林克                         |\n| 2013.9.1   | 我的舅舅                                 | 让·克劳德·卡里尔                      |\n| 2013.9.19  | 布拉格小城画像                           | 杨·聂鲁达                             |\n| 2013.10.04 | 寻路中国                                 | 彼得·海斯勒                           |\n| 2013.10.05 | 愚人颂                                   | 伊拉斯谟                              |\n| 2013.10.10 | 宇宙尽头的餐馆                           | 道格拉斯·亚当斯                       |\n| 2013.11.01 | 西游记                                   | 吴承恩                                |\n| 2013.12.24 | 美国史纲                                 | 房龙                                  |\n| 2013.12.25 | 有顶天家族                               | 森见登美彦                            |\n| 2013.12.29 | 闻香识女人                               | 乔瓦尼·阿尔皮诺                       |\n| 2014.2.9   | 官场现形记                               | 李宝嘉                                |\n| 2014.3.10  | 哈尼娅                                   | 显克维奇                              |\n| 2014.4.13  | 狐狸的故事                               | 森见登美彦                            |\n| 2014.4.16  | 再会，谢谢所有的鱼                       | 道格拉斯·亚当斯                       |\n| 2014.4.28  | 生命，宇宙以及一切                       | 道格拉斯·亚当斯                       |\n| 2014.5.7   | 城邦暴力团                               | 张大春                                |\n| 2014.7.13  | 四叠半神话大系                           | 森见登美彦                            |\n| 2014.7.21  | 鹿男                                     | 万城目学                              |\n| 2014.7.27  | 鸭川小鬼                                 | 万城目学                              |\n| 2014.7.28  | 孔明，你又乱来了                         | 酒见贤一                              |\n| 2014.8.3   | 丰臣公主                                 | 万城目学                              |\n| 2014.8.17  | 萨德侯爵夫人                             | 三岛由纪夫                            |\n| 2014.8.18  | 睡美人                                   | 川端康成                              |\n| 2014.8.20  | 舞姬                                     | 川端康成                              |\n| 2014.8.31  | 空色勾玉                                 | 获原规子                              |\n| 2014.9.01  | 告白                                     | 凑佳苗                                |\n| 2014.10.04 | 白鸟异传                                 | 获原规子                              |\n| 2014.10.10 | 恋文的技术                               | 森见登美彦                            |\n| 2014.10.13 | 宵山万华镜                               | 森见登美彦                            |\n| 2014.10.21 | 茶花女                                   | 小仲马                                |\n| 2014.10.21 | 赎罪                                     | 凑佳苗                                |\n| 2014.11.09 | 希腊罗马名人传（上册）                   | 普鲁塔克                              |\n| 2014.12.26 | 美丽新世界                               | 阿道司·赫胥黎                         |\n| 2015.01.11 | 春宵苦短，少女前进吧！                   | 森见登美彦                            |\n| 2015.01.14 | 金枝                                     | 詹姆斯·弗雷泽                         |\n| 2015.01.24 | 往复书简                                 | 凑佳苗                                |\n| 2015.02.19 | 众病之王·癌症                            | Siddhartha Mukherjee                  |\n| 2015.02.22 | 海伯利安                                 | 丹·西蒙斯                             |\n| 2015.04.01 | 宵山万华镜                               | 森见登美彦                            |\n| 2015.04.14 | 海伯利安的陨落                           | 丹·西蒙斯                             |\n| 2015.04.17 | 安迪密恩                                 | 丹·西蒙斯                             |\n| 2015.04.20 | 安迪密恩的觉醒                           | 丹·西蒙斯                             |\n| 2015.10.01 | 桃花井                                   | 蒋晓云                                |\n| 2016.01.09 | 人类群星闪耀时                           | 茨威格                                |\n| 2016.01.16 | 安珀志（1-5）                            | 罗杰·泽拉兹尼                         |\n| 2016.02.05 | 安珀志（6-10）                           | 罗杰·泽拉兹尼                         |\n| 2016.02.18 | 光明王                                   | 罗杰·泽拉兹尼                         |\n| 2016.02.20 | 光与暗的生灵                             | 罗杰·泽拉兹尼                         |\n| 2016.05.08 | 阴阳师                                   | 梦枕貘                                |\n| 2017.07.21 | 甘南纪事                                 | 杨显惠                                |\n| 2017.07.22 | 神的九十亿的名字                         | 阿瑟·克拉克                           |\n| 2017.07.22 | 活着                                     | 余华                                  |\n| 2017.07.24 | 大国的崩溃 苏联解体的台前幕后            | 沙希利·浦洛基(Serhii Plokhy)          |\n| 2017.07.31 | 银河帝国                                 | 艾萨克·阿西莫夫                       |\n| 2017.12.26 | 沙丘                                     | 弗兰克·赫伯特                         |\n| 2018.03.29 | 洪业：清朝开国史                         | （美国）魏斐德（Wakeman.F.E.）        |\n| 2018.04.26 | 凤凰项目：一个 IT 运维的传奇故事         | Gene Kim, Kevin Behr, George Spafford |\n| 2018.04.29 | 写给大家看的设计书                       | [美] Robin Williams                   |\n| 2018.05.05 | 三体                                     | 刘慈欣                                |\n","isEmpty":false,"excerpt":"","stats":{"ctimeMs":1546997551046.7698},"author":"陈三","description":"","datePublished":1359383731000,"dateModified":1359383731000,"template":"page.js"},{"filePath":"_posts/a-tale-of-east-asian-history-british-loan-sharks-and-a-russian-hacker.md","title":"东亚史，英国高利贷，及一个俄罗斯黑客的故事","date":"2012-11-25T05:56:30.000Z","permalink":"/a-tale-of-east-asian-history-british-loan-sharks-and-a-russian-hacker/","tags":["翻译"],"content":"{:toc}\n\n> 本文译自 [A Tale of East Asian History, British Loan Sharks, and a Russian Hacker](http://muninn.net/blog/2012/06/a-tale-of-east-asian-history-british-loan-sharks-and-a-russian-hacker/)\n\n几个礼拜前，早上 6:30 我醒来接电话。\n\n“我想买你的域名 froginawell.net，500 美元，怎么样？”\n\n我本能地在电话里掩饰我的声音，不想让人知道其实我刚被电话惊醒。在这极度唐突的提议之前，可能还有些开场白，不过我还未完全清醒。\n\n[井底之蛙](http://froginawell.net/ \"访问井底之蛙网站\")是我早在 2004 年创建的网站，教授、研究生们在上面撰写一些关于东亚历史的学术博客。在我完成博士论文后，我就很少在上面发表什么了，不过我一些了不起的共事者们一直活跃着。因为我们有大量东亚历史主题的内容，网站吸引了相当数量的流量，特别是来自 Google 的，搜索「中国古代性交（ancient Chinese sex）」，又或者，很明显的，「满洲缠足（Manchu foot binding）」。我想这些访客会发现，这些链接还不够给他们搔痒。我们的网站一直都没有广告，不管怎样，我打算继续保持下去。\n\n我拒绝了这位绅士，回去接着睡觉。等我去到办公室，我看见一封他发来的电子邮件，且让我们叫他西蒙。他报了一样的价，是在他打电话给我前几分钟发的。我回复了他的电子邮件，解释说我不打算出售域名。\n\n一个星期后，西蒙又发了封邮件。这一次，他想租我的域名。\n\n> 看来有人黑掉你的网站？又或者你自己换了你的主页标题？？不管怎么说，你的网站关键词排名上升了，所以我真的想租你的主页。我会增加我的报价，每天 150 美元。\n\n每天 150 美元？关键词？井底之蛙能给他提供什么关键词啊？他的电子邮件地址透露，他在一家英国太阳能公司工作。该网站看起来是合法的，在一个「合理的价格」上，为家庭提供太阳能安装。我徒劳地搜寻任何线索，想弄明白，为什么他会想要 froginawell.net 域名。我在我们网站上搜索任何有关太阳能能量或能源的东西。没有结果。我不想问他，因为我不想给他希望。\n\n至于黑客攻击，这事以前发生过。有时候，我们升级 WordPress 的速度有点慢，于是有过两次，我们的博客都被所谓的 “pharma hack” 攻击。这种攻击很阴险，会让你的网站看起来跟以前一样，但是 Google 搜索进入你的网站时，它就换掉所有博客文章的标题，化身为你可以想像的任何一种在线药物订购网站的广告。众所周知，这很难追查，因为黑客越来越擅长隐藏他们的代码，或者在 WordPress 深层次目录结构中，又或者在你无法察觉的数据库角落里。\n\n然而，这一次，看起来并没有发生 pharma hack。不过我 froginawell.net 的主页被改了，从一个简单的 HTML 文件改成一个 PHP 文件，这就允许页面执行代码。该文件的顶部添加了一行新代码，包含一个命令、一堆乱码。当时，我并没有时间深究。我正打算完成我博士论文的倒数第二章。于是我删除了有问题的文本，把我的主页改回 HTML，更改了我的帐户密码，重新安装中国博客（这在之前曾经被黑客入侵过），并发送一封电子邮件向我的主机商寻求帮助，希望能处理这起安全攻击。我的主机商回复说，如果我付给他们我现在所付的近两倍的钞票，添置一个新的安全服务，他们会很乐于帮忙的。否则，我得自己干了。\n\n我只能是根据我所认为的被黑文件的位置，做了个不太完整的清理。之后我回复西蒙，「这个报价很慷慨，但我还是不需要。我已经决定保持我们的项目不带任何广告。」\n\n西蒙于同一天再次回信。他仍然在 Google 上看到我被黑页面的标题。我到 Google 搜索井底之蛙，却看不出他到底讲的是什么，我猜想他看的应该是一些旧文章，在它们被黑时 Google 缓存了页面。西蒙写道：\n\n> 你知不知道为什么人们突然要攻击你？因为您的网站目前的盈利潜力。\n> \n> 如果您愿意开出价格，我将不胜感激，因为每个人都有一个价，我不希望你我错过这个机会。如果我们之间能达成一项协议，我可以给个更高的每日费用。你觉得每天 250 美元怎样。如果钱不是你想要的，你可以每天捐出 250 美元给慈善机构。\n\n每天 250 美元？这真是彻头彻尾的神经错乱了，实在太可疑了。当时是阵亡将士纪念日，周末时间，我正在旅行。如果邀约是真的，并且我愿意把井底之蛙首页换成某些人的广告的话，对我来说，处理起来也很痛苦，而且这一切都太可疑了。我拒绝了他，并告诉他，这件事没什么好谈，任何价格都不能让我在井底之蛙上放广告。\n\n西蒙又回了我，这是最后一次。\n\n> 作为一个商人，我总是相信，天下没有买不到的东西，只有谈不拢的价格，尤其是在谈及商业内容时。不过，我尊重你的决定，这也将是最后一次发消息给你。我再最后出一个价，如果你还是决定不想要，我就再也不烦你了。每天 500 美元，提前支付。一年差不多 20 万美金。\n\n显然，他对我的拒绝感到困惑，不明白为什么我完全不像是一个理性经济人。我理解他的颓然。大概，他不曾遇见许多​​新从大学毕业的这类学生。我又回了他一轮，再次拒绝他的邀约，不过也希望他在他的生意上有好运气，在当时那个点，我仍然认为他是在一个太阳能电力公司工作。\n\n我回到家的时候，下定决心要解决两个谜团：\n\n1. 西蒙在 Google 查找井底之蛙时，看到的还是被黑状态的是什么？\n2. 究竟为什么，西蒙会先是出 500 美元购买我的域名，到最后想要每天 500 美元租我的网站？\n\n我发现的第一件事情是，我的网站仍有问题。黑客们再次修改我的主页，把它变成一个 php 文件，并在顶部添加了一个命令，以及一堆乱七八糟的东西。他们的后门并没有如我所预料地放在中国博客里，而是在其他地方。我必须对黑客行为做一个逆向工程。\n\n## 剖析攻击\n\n黑客添加到我的主页顶部的命令是 “pr​​eg_replace” 函数，在 PHP 中用于从某些文本中搜索一个词组，并用其他一些文字替代。\n\n```php\npreg_replace(\"[what you are searching for]\",\"[what you wish to replace it with]\",\"[the text to search]\")\n```\n\n在这个案例里，那些命令对我来讲显得非常晦涩，因为根本都是一堆乱码，如 ” \\x65\\166\\x61\\154 “。这其实只是 ASCII 码文本以十进制和十六进制两个不同格式进行了混合。PHP 知道不要把它们当普通数字对待，因为有转义 “\\” 字符，后面跟的 x 表示十六进制数字。在这个图中，你可以找到它们的含义。例如，上面的文字，以 \\ X65 开头的，这是十六进制表示的 “e”，然后是十进制表示的 “v”，接着又换回十六进制，这次是 “a”，最后仍是十进制，”l”，合起来就是 “eval”。\n\n对于计算机来说，这很明了，但对我这样的人类来说，要弄明白发生什么却很困难。我必须先将所有的乱七八糟的字符转换成常规字符。我使用 Python 来转换。在我的 Mac 上，打开终端，键入 python，然后用 python 的 print 命令来输出那一段乱码 ASCII 块：\n\n```python\nprint(\"[put your gibberish here]\")\n```\n\n这生成一个命令，说的是：\n\n```\nLook for: |(.*)|ei\nReplace it with: eval('$kgv=89483;'.base64_decode(implode(\"\\n\",file(base64_decode(\"\\1\")))));$kgv=89483;\nIn the text:         L2hvbWUvZnJvZ2kyL3B1YmxpY19odG1sL2tvcmVhL3dwLWluY2x1ZGVzL2pzL2Nyb3AvbG9nLy4lODI4RSUwMDEzJUI4RjMlQkMxQiVCMjJCJTRGNTc=\n```\n\n现在，我总算找到感觉了。但是，这末尾的又是什么全新风味的杂乱代码？该文本编码使用 Base64 编码方法进行编码。如果你有一个 Base64 编码的文本文件，你可以在 Mac OS X 或 Linux 命令行里通过下述命令解码：\n\n```bash\nbase64 -i encoded-text.txt -o outputed-decoded.txt\n```\n\n您也可以使用 Python，PHP，Ruby 等解码 base64，又或者在线的解码器。通过解码，得到了文件地址，该文件中包含更多要执行的代码：\n\n```\n[…]public_html/korea/wp-includes/js/crop/log/.%828E%0013%B8F3%BC1B%B22B%4F57\n```\n\n但不只是这一个文件。那里有许多文件，里面包含着可替换的主页文本。我主页里的代码，通过前面一个命令，运行了其他隐藏在我的韩国博客一个深层目录的命令。虽然这些文件名和它们的内容使用一系列方法编码，比如 base64 编码，MD5 加密，字符转换成数字，任意值重复，还包括许多以 JSON 格式存储的内容。我还是耐心地找出所有细节，不过它似乎只针对 Google 提供不一样的主页，并且只在某些情况下。\n\n其中一个被黑的文件会生成一个英国 payday loan 诈骗网站 speedypaydayloan dot co dot uk，它连接到一个假的伦敦公司 “D and D Marketing”，可以在网上看到很多地方讨论它的诈骗行为。换句话说，英国，并且只有英国的用户在访问 Google、查找 “payday loans” 时，井底之蛙上被狡猾入侵过的主页将他们重定向到一个诈骗网站，又或重定向到我网站上一个被编码过的巨大列表中的任意其他网站。\n\n我很快就发现，不仅仅只是这些韩国博客下的文件显得可疑。它们只是黑客用来生成他们所期望有的具体结果的文件。经过对大量隐蔽代码的更多解码，我终于找到输送系统本身。要部署这个特殊的组合 – 重定向和用来重定向的隐藏页，攻击者使用一个黑客梦想套装：被称为 “WSO 2.5“ 的东西。一旦他们发现我域名上旧版本 WordPress 的安全问题，他们就可以把 WSO 套件安装到隐蔽位置，这个位置有别于上述的攻击。虽然我不知道这个 Youtube 视频（没有声音）能保留多久，你可以[在这里](https://www.youtube.com/watch?v=y-Z5-uHvONc)看到黑客是怎样使用 WSO 的。真正用来安装控制我服务器的后门套件 PHP 代码可以在 [pastebin 这里](https://pastebin.com/N0eh3Q7Y)找到。\n\n![](http://muninn.net/blog/wp-content/uploads/2012/06/Screen-Shot-2012-06-05-at-11.44.06-300x118.png \"屏幕截图在11.44.06 2012-06-05\")\n\n## 西蒙和他的朋友们\n\n那么，这一切跟我们的朋友西蒙及他的太阳能电力公司是怎么联系上的？ Google [网站管理员工具](https://www.google.com/webmasters/)显示，井底之蛙网站目前最热门查询词是 “payday loans”，这排名大约是在五月初上去的，有几十万的展示数，也就是那时网站被黑掉。有什么在驱动被黑的网站排名上升。\n\n西蒙在他给我的一封电子邮件中写道，他涉足很多行业，这表明，他不仅仅只为一个太阳能电力公司工作。搞清楚我那被黑客攻击的网站是什么情况后，我搜索了他的全名及 “loans uk”，很快就发现，他（还经常是他的地址）注册了一系列的域名，其中至少有一个域名已经被暂停。这包括一个 payday loan 网站，一个移动电话交易网站，一个家庭贷款经纪人站，以及一些其他类型的看起来已经不存在的金融机构网站，还有另一家公司，致力于可替代能源。我猜测，西蒙的关键短语只能是 “payday loans”了，他看到了一个赚快钱的方式，就是通过新被攻陷的井底之蛙网站来宣传它的财务欺诈网站。他真的是认真的要付出那个数目吗？他是如何计划让这一切成功的？他知道这个 Google 排名可能只是一个被深度入侵的网站一时的排名吗？\n\n西蒙的 500 美元报价并不是最后。我删除了所有有问题的文件，安装额外的安全保护，更改密码，并开始监视我的服务器原始访问文件。我要求谷歌网站管理员工具重新审查我的网站，希望能帮我摆脱英国的 payday loan 业务。然而，邀约继续来。\n\n卢克，西蒙的竞争对手之一，给我写了一封十分礼貌的电子邮件，提供了一个更是随时可得的邀约，也顺便证实我倒腾文件时发现的东西：\n\n> 您可能不知道，但您的网站已经被一个俄罗斯互联网营销分支机构攻陷，它们试图通过搜索关键词 “payday loans” 从英国赚钱……粗略估计，这个链接当前的位置可以让黑客一周内赚入 10,000 美金。我们是这个黑客在英国地区的大型竞争对手，当然我们不屑他的这种行为，我们想阻止他这样获利，我们帮你换掉他插入的这条链接，换上我们的，我们每期支付佣金给您…\n\n这是“聪明的东西”，他解释说，“但不太合法。”我礼貌地拒绝了他。\n\n![](http://muninn.net/blog/wp-content/uploads/2012/06/Screen-Shot-2012-06-05-at-11.46.17-300x263.png \"屏幕截图在11.46.17 2012-06-05\")\n\n我刚清理完我的服务器没多久，它就开始遭遇 DOS 攻击（拒绝服务攻击）。井底之蛙的三个博客处在火力中，来自世界各地的一大打僵尸机器，短短 10 分钟内，试图读取每个博客主页超 48,000 次。我的主机商立即暂停我的帐户，因为我给他们的服务器造成不必要的压力。他们建议我花 10 倍左右我现在的主机价格买个托管专用服务器。一年前，因为我的博客受到 DOS 攻击 – 其中大部分来自中国，我才把它们移到现在这个主机商里。之前的主机商是礼貌地拒绝做任何事情。现在的主机商总算客气，在监测一天的情况后恢复了我的站点，但没有什么能够阻拦一个攻击者租来几分钟的僵尸机器来攻击网站。这种无助感真是太可怕了，真的只能用很多钱来反击 – 是的，钱 – 我不想通过 payday loan 业务赚的钱。为了给这杂耍加点料，在网站被暂停后的几个小时内，两个不同的安全公司与我联系，号称保证能抵抗 DOS 攻击，并问我是否愿意跟他们讨论签署他们那昂贵的服务。他们怎么就知道我被 DOS 攻击了，而不是其他一些原因被暂停？\n\n几天后，又一个 payday loan 操作者，且让我们叫他格兰特，通过 Twitter 与我联系。他解释说，“俄罗斯人”应该庆幸 – 他相信是俄罗斯人黑入我的站，因为他的地理位置而不会受到任何罪罚，不过他建议，我们可以“利用这种情况”，把我站点上的链接分一半给他。\n\n> 我会每天付款给你，根据 Paypal 或银行转账赚到的数目。我说个潜在利润的数目，过去我排第 1 位时，我可以每天正常地收入 15,000 英镑。我看你的网站排名现在会上下波动，所以我不确定到底它能赚多少…不过我想 4 位数一天应该没问题，不过没尝试，我不能肯定。\n\n我拒绝了他，并解释说，我已经清除了攻击。只是反馈到 Google 里还需要些时间。然而，在我向他请求更多他所知道的关于黑客的更多信息后，格兰特很热心地给我发一个长长的清单，都是些攻击我网站的黑客攻陷的网站。不过这些其他网站在这个游戏中唯一的作用是使用锚文本 “payday loans” 反向链接到井底之蛙，以期迅速提高我网站排名。卢克曾经表示，这种方法之所以有效，是因为井底之蛙网站在 Google 中已经是一个相对“受信任”的站点。格兰特（他说他是直接从沙滩上给我电子邮件，我想对于每天从这种事情上赚入成千上万英镑的人来说沙滩确实是个好地方）还提供给我半打其他网站，它们现在正受到同样的隐藏页和重定向攻击。他推测，我受到的 DOS 攻击是来自他的其他竞争对手，他们不是试图花钱买我的合作，而是投入一些微不足道的成本，来简单地把我的网站从互联网上搞瘫掉。\n\n谢天谢地，我的考验将很快结束，我只需密切关注我的服务器。感谢格兰特，卢克和西蒙，虽然，他们的俄罗斯复仇女神仍在继续他的工作。最后一个从格兰特发来的信息，\n\n> 现在，Google 英国上排第一的是一家美国电台，这下我又有得忙了，lol。","isEmpty":false,"excerpt":"","stats":{"ctimeMs":1546997551058.255},"author":"陈三","description":"","datePublished":1353822990000,"dateModified":1353822990000,"template":"post.js"},{"filePath":"_posts/about-translation.md","title":"关于技术文章的翻译","date":"2016-01-06T15:29:56.000Z","tags":["翻译"],"content":"{:toc}\n\n我很久不翻译技术类文章了，以后基本也不会再参与。\n\n[Babeljs](https://babeljs.io/) 6 出来后，互联网上有一堆文章需要更新。因为 babel 6 与上一版本比，变化很大。\n\n去年，我在图书馆借过一本 Ruby on Rails (ROR) 的书籍，里面介绍的 ROR 的版本还停留在 2.x，而现在 ROR 的稳定版本是 v4.2.5，5.x 的 beta 版本也已推出。于是，这本书接下来基本只能吃灰。\n\n世界变化的脚步很快，翻译跟不上。\n\n我看着自己去年给 Google WebFundamentals 翻译的中文，只觉得头疼。","isEmpty":false,"excerpt":"","stats":{"ctimeMs":1546997551058.4207},"author":"陈三","description":"","datePublished":1452094196000,"dateModified":1452094196000,"permalink":"/about-translation/","template":"post.js"},{"filePath":"_posts/babel-js.md","title":"babel 7 教程","date":"2016-01-01T10:25:05.000Z","dateModified":1535472000000,"permalink":"/babel-js/","tags":["Babel.js","前端开发","教程"],"content":"{:toc}\n\n在前端开发领域，浏览器兼容性问题来来去去，不曾消失过。除了 CSS，我们还要面对 JavaScript 的兼容性问题：你用了 JavaScript 的 A 特性，能够在 B 浏览器上正常运行，却在 C 浏览器的 D 版本上报错。\n\n这正是 Babel.js 想解决的问题。也因此，Babel 项目非常庞大，而且在不断更新、调整，这意味着，一篇教程不可能囊括所有 - 当然，我也没那种打算。\n\n本文基于 babel 7.0.0。\n\n## @babel/cli\n\n[`@babel/cli`](https://babeljs.io/docs/en/babel-cli/) 是 babel 提供的命令行工具，用于命令行下**编译**源代码。\n\n这里假定我们已通过 `npm init` 初始化项目。\n\n首先，在项目中安装 `@babel/cli`：\n\n```bash\nnpm install --save-dev @babel/core @babel/cli\n```\n如果你用过 babel 6，可能要问，怎么不是 `npm install --save-dev babel-cli`？`@` 符号又是什么？这是 babel 7 的一大调整，原来的 `babel-xx` 包统一迁移到[babel 域下](https://docs.npmjs.com/misc/scope) - 域由 `@` 符号来标识，一来便于区别官方与非官方的包，二来避免可能的包命名冲突。\n\n现在假定我们的项目下有一个 `script.js` 文件，内容是：\n\n```js\nlet fun = () => console.log('hello babel.js')\n```\n我们试试运行 `npx babel script.js`：\n\n```bash\n$ npx babel script.js\nlet fun = () => console.log('hello babel.js');\n```\n还是原来的代码，没有任何变化。说好的编译呢？\n\n这个调整则是在 [babel 6](https://babeljs.io/blog/2015/10/29/6.0.0) 里发生的。Babel 6 做了大量模块化的工作，将原来集成一体的各种编译功能分离出去，独立成插件。这意味着，默认情况下，当下版本的 babel 不会编译代码。\n\n## babel 插件\n\n换句话说，我们要将上面的箭头函数编译成 ES5 函数，需要安装额外的 babel 插件。\n\n首先，安装 [@babel/plugin-transform-arrow-functions](https://github.com/babel/babel/tree/master/packages/babel-plugin-transform-arrow-functions)：\n\n```bash\nnpm install --save-dev @babel/plugin-transform-arrow-functions\n```\n然后，在命令行编译时指定使用该插件：\n\n```bash\n$ npx babel script.js --plugins @babel/plugin-transform-arrow-functions\nlet fun = function () {\n  return console.log('hello babel.js');\n};\n```\n编译成功。\n\n## 配置文件 .babelrc\n\n随着各种新插件的加入，我们的命令行参数会越来越长。\n\n这时，我们可以新建一个 `.babelrc` 文件，把各种命令行参数统一到其中。\n\n比如，要配置前面提到过的箭头函数插件：\n\n```json\n{\n  \"plugins\": [\"@babel/plugin-transform-arrow-functions\"]\n}\n```\n之后，在命令行只要运行 `npx babel script.js` 即可，babel 会自动读取 `.babelrc` 里的配置并应用到编译中：\n\n```bash\n$ npx babel script.js\nlet fun = function () {\n  return console.log('hello babel.js');\n};\n```\n\n## babel 套餐\n\n我们有一个项目，页面要求支持 IE 10，但 IE 10 不支持箭头函数、`class` 及 `const`，可是你喜欢用这些新增的 JavaScript 语法，你在项目里写了这么一段代码：\n\n```js\nconst alertMe = (msg) => {\n  window.alert(msg)\n}\nclass Robot {\n  constructor (msg) {\n    this.message = msg\n  }\n  say () {\n    alertMe(this.message)\n  }\n}\nconst marvin = new Robot('hello babel')\n\n```\n显然，在 IE 10 下这段代码报错了。\n\n好消息是，babel 有各种插件满足你的上述需求。\n\n我们来安装相应插件：\n\n```bash\n$ npm install --save-dev @babel/plugin-transform-arrow-functions @babel/plugin-transform-block-scoping @babel/plugin-transform-classes\n```\n接着，将它们加入 `.babelrc` 配置文件中：\n\n```json\n{\n  \"plugins\": [\n    \"@babel/plugin-transform-arrow-functions\",\n    \"@babel/plugin-transform-block-scoping\",\n    \"@babel/plugin-transform-classes\"\n    ]\n}\n```\n然后运行 `npx babel script.js`，就有编译结果了：\n\n```js\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar alertMe = function (msg) {\n  window.alert(msg);\n};\n\nvar Robot =\n/*#__PURE__*/\nfunction () {\n  function Robot(msg) {\n    _classCallCheck(this, Robot);\n\n    this.message = msg;\n  }\n\n  _createClass(Robot, [{\n    key: \"say\",\n    value: function say() {\n      alertMe(this.message);\n    }\n  }]);\n\n  return Robot;\n}();\n\nvar marvin = new Robot('hello babel'); \n```\n只是，这样安装插件、配置 `.babelrc` 的过程非常乏味，而且容易出错。通常，我们不会关心到具体的某个 ES2015 特性支持情况这个层面，我们更关心浏览器版本这个层面。\n\n你说，我不想关心 babel 插件的配置，我只希望，给 babel 一个**我想支持 IE 10** 的提示，babel 就帮我编译出能在 IE 10 上正常运行的 JavaScript 代码。\n\n欢迎 [@babel/preset-env](https://babeljs.io/docs/plugins/preset-env/)。\n\n等等，Preset 是什么？前面我们已经认识了插件，那么不妨把 Preset 理解为套餐，每个套餐里打包了不同的插件，这样安装套餐就等于一次性安装各类 babel 插件。\n\n我们来看看怎样使用 `@babel/preset-env`。\n\n首先在项目下安装：\n\n```bash\n$ npm install --save-dev @babel/preset-env\n```\n然后修改 `.babelrc`：\n\n```json\n{\n  \"presets\": [\"@babel/preset-env\"]\n}\n```\n运行 `npx babel script.js`，输出结果如下：\n\n```js\n\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar alertMe = function alertMe(msg) {\n  window.alert(msg);\n};\n\nvar Robot =\n/*#__PURE__*/\nfunction () {\n  function Robot(msg) {\n    _classCallCheck(this, Robot);\n\n    this.message = msg;\n  }\n\n  _createClass(Robot, [{\n    key: \"say\",\n    value: function say() {\n      alertMe(this.message);\n    }\n  }]);\n\n  return Robot;\n}();\n\nvar marvin = new Robot('hello babel');\n```\nWow，与前面辛苦配置各种插件后的输出结果几乎一模一样。\n\n可是，我们还没告诉 babel 我们要支持 IE 10 的，为什么它却好像预知一切？\n\n我们来看 `babel-preset-env` 的一段文档：\n\n> Without any configuration options, babel-preset-env behaves exactly the same as babel-preset-latest (or babel-preset-es2015, babel-preset-es2016, and babel-preset-es2017 together).\n\n默认情况下，`babel-preset-env` 等效于三个套餐，而不巧我们前面安装的几个插件已经囊括在 `babel-preset-es2015` 中。\n\n那么，如果我只想支持最新版本的 Chrome 呢？\n\n这时我们可以调整 `.babelrc` 的配置：\n\n```json\n{\n  \"presets\": [\n    [\"@babel/preset-env\", {\n      \"targets\": {\n        \"browsers\": [\"last 1 Chrome versions\"]\n      }\n    }]\n  ]\n}\n```\n再次编译，结果如下：\n\n```bash\n$ npx babel script.js\n\"use strict\";\n\nconst alertMe = msg => {\n  window.alert(msg);\n};\n\nclass Robot {\n  constructor(msg) {\n    this.message = msg;\n  }\n\n  say() {\n    alertMe(this.message);\n  }\n\n}\n\nconst marvin = new Robot('hello babel');\n```\n最新版本的 Chrome 已经支持箭头函数、`class`、`const`，所以 babel 在编译过程中，不会编译它们。这也是为什么我把 `@babel/preset-env` 称为 JavaScript 的 **Autoprefixer**。\n\n## babel-polyfill\n\n> Babel includes a polyfill that includes a custom [regenerator runtime](https://github.com/facebook/regenerator/blob/master/packages/regenerator-runtime/runtime.js) and [core-js](https://github.com/zloirock/core-js).\n\n基本上，babel-polyfill 就是 `regenerator runtime` 加 `core-js`。\n\n可是，为什么需要 polyfill 这所谓的垫片？前面聊到 `@babel/preset-env` 时，不是说只要定义好我想支持的目标浏览器，babel 就能编译出能运行在目标浏览器上的代码吗？\n\n我们暂时去掉 `babel-`，从 polyfill 说起。\n\n拿 `findIndex` 来说，IE 11 仍不支持该方法，假如你的代码里写了 `findIndex`，IE 11 浏览器会报如下错误：\n\n```console\nObject doesn't support property or method 'findIndex'\n```\n怎么办，这时我们就可以写个 [polyfill](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex#Polyfill)：\n\n```js\n// https://tc39.github.io/ecma262/#sec-array.prototype.findIndex\nif (!Array.prototype.findIndex) {\n  Object.defineProperty(Array.prototype, 'findIndex', {\n    value: function(predicate) {\n     // 1. Let O be ? ToObject(this value).\n      if (this == null) {\n        throw new TypeError('\"this\" is null or not defined');\n      }\n\n      var o = Object(this);\n\n      // 2. Let len be ? ToLength(? Get(O, \"length\")).\n      var len = o.length >>> 0;\n\n      // 3. If IsCallable(predicate) is false, throw a TypeError exception.\n      if (typeof predicate !== 'function') {\n        throw new TypeError('predicate must be a function');\n      }\n\n      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.\n      var thisArg = arguments[1];\n\n      // 5. Let k be 0.\n      var k = 0;\n\n      // 6. Repeat, while k < len\n      while (k < len) {\n        // a. Let Pk be ! ToString(k).\n        // b. Let kValue be ? Get(O, Pk).\n        // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).\n        // d. If testResult is true, return k.\n        var kValue = o[k];\n        if (predicate.call(thisArg, kValue, k, o)) {\n          return k;\n        }\n        // e. Increase k by 1.\n        k++;\n      }\n\n      // 7. Return -1.\n      return -1;\n    }\n  });\n}\n```\n上面这段代码的意思是，如果目标环境中已经存在 `findIndex`，我们什么都不做，如果没有，我们就在 `Array` 的原型中定义一个。这便是 polyfill 的意义。babel-polyfill 同理。\n\n虽说浏览器的特性支持状况千差万别，但其实可以提炼出两类：\n\n1. 大家都有，只是 A 语法与 B 语法的区别；\n2. 不是大家都有：有的有，有的没有。\n\nbabel 编译过程处理第一种情况 - 统一语法的形态，通常是高版本语法编译成低版本的，比如 ES6 语法编译成 ES5 或 ES3。而 babel-polyfill 处理第二种情况 - 让目标浏览器支持所有特性，不管它是全局的，还是原型的，或是其它。这样，通过 babel-polyfill，不同浏览器在特性支持上就站到同一起跑线。\n\n下面我们看看 babel-polyfill 的用法。\n\n### 安装 babel-polyfill\n\n```bash\n$ npm install --save @babel/polyfill\n```\n### 使用 babel-polyfill\n\n我们需要在程序入口文件的顶部引用 `@babel-polyfill`：\n\n```js\nrequire('@babel/polyfill')\n[].findIndex('babel')\n```\n或者使用 ES6 的写法：\n\n```js\nimport '@babel/polyfill'\n[].findIndex('babel')\n```\n需要注意的是，babel-polyfill 不能多次引用。如果我们的代码中有多个 `require('@babel/polyfill')`，则执行时会报告错误：\n\n```console\nonly one instance of @babel/polyfill is allowed\n```\n这是因为引入的 babel-polyfill 会在全局写入一个 [`_babelPolyfill` 变量](https://github.com/babel/babel/blob/master/packages/babel-polyfill/src/index.js#L19)。第二次引入时，会检测该变量是否已存在，如果已存在，则抛出错误。\n\n### 注意事项\n\n如前面所说的，babel-polyfill 其实包含 `regenerator runtime`、`core-js`，如果你的代码只需要其中一部分 polyfill，那么你可以考虑直接引入 `core-js` 下的特定 polyfill，不必使用 babel-polyfill 这样的庞然大物。\n\n另一种办法，是配合 `@babel/preset-env` 的 [`useBuiltIns`](https://babeljs.io/docs/en/next/babel-preset-env.html#usebuiltins) 配置。\n\n## babel-runtime\n\n`@babel/runtime` 是 babel 生态里最让人困惑的一个包。而在 babel 7 下，我们还多了一个 `@babel/runtime-corejs2`。\n\n我们先来看看 `@babel/runtime` 的 `package.json` 里的 [`description`](https://github.com/babel/babel/blob/master/packages/babel-runtime/package.json#L4) 怎么写：\n\n> babel's modular runtime helpers\n\n有点不知所谓。\n\n不过从 `package.json` 里没有 `main` 字段我们可以看出，它的用法肯定不是 `require('babel-runtime')` 这样。\n\n那么，babel-runtime 与 babel-polyfill 的区别究竟是什么？\n\n我们拿 `Object.assign` 为例，剖析下 babel-polyfill 与 babel-runtime 的异同。\n\n我们知道，IE 11 不支持 `Object.assign`，此时，我们有俩种候选方案：\n\n1. 引入 babel-polyfill，补丁一打，`Object.assign` 就被创造出来\n2. 配置 [`@babel/plugin-transform-object-assign`](https://babeljs.io/docs/plugins/transform-object-assign/)\n\n第二种方案中，babel 会将所有的 `Object.assign` 替换成 `_extends` 这样一个辅助函数。如下所示：\n\n```js\nObject.assign({}, {})\n```\n编译成：\n\n```js\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n_extends({}, {});\n```\n问题是，如果你的项目里有 100 个文件，其中有 50 个文件里写了 `Object.assign`，那么，坏消息来了，`_extends` 辅助函数会出现 50 次。\n\n怎么办？我们自然而然会想到把 `_extends` 分离出去，然后在每个文件中引入 - 这正是 `@babel/runtime` 的作用：\n\n```js\nvar _extends = require(\"@babel/runtime/helpers/extends\");\n\n_extends({}, {});\n```\n非常漂亮。可没人想要手动转换这些代码。\n\n于是 babel 提供了 [`@babel/plugin-transform-runtime`](https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-runtime/README.md) 来替我们做这些转换。\n\n### @babel/plugin-transform-runtime\n\n我们首先安装插件：\n\n```bash\n$ npm install --save-dev @babel/plugin-transform-runtime\n```\n然后再安装 babel-runtime：\n\n```bash\n$ npm install @babel/runtime\n```\n最后在 `.babelrc` 中配置：\n\n```json\n{\n  \"plugins\": [\n    \"@babel/plugin-transform-object-assign\",\n    \"@babel/plugin-transform-runtime\"\n  ]\n}\n```\n这样，我们不需要 babel-polyfill 也一样可以在程序中使用 `Object.assign`，编译后的代码最终能够正常运行在 IE 11 下。\n\n> **提问**：在经过 `@babel/plugin-transform-runtime` 的处理后，IE 11 下现在有 `Object.assign` 吗？\n\n答案是，仍然没有。\n\n这正是 babel-polyfill 与 babel-runtime 的一大区别，前者改造目标浏览器，让你的浏览器拥有本来不支持的特性；后者改造你的代码，让你的代码能在所有目标浏览器上运行，但不改造浏览器。\n\n如果你还是困惑，我推荐一个非常简单的区分方法 - 打开浏览器开发者工具，在 console 里执行代码：\n\n1. 引入 babel-polyfill 后的 IE 11，你可以在 console 下执行 `Object.assign({}, {})`\n2. 而引入 babel-runtime 后的 IE 11，仍然提示你：`Object doesn't support property or method 'assign'`\n\n## babel-register\n\n经过 babel 的编译后，我们的源代码与运行在生产下的代码是不一样的。\n\n[babel-register](http://babeljs.io/docs/usage/babel-register/) 则提供了动态编译。换句话说，我们的源代码能够真正运行在生产环境下，不需要 babel 编译这一环节。\n\n我们先在项目下安装 babel-register：\n\n```bash\n$ npm install --save-dev @babel/register\n```\n然后在入口文件中 `require`：\n\n```js\nrequire('@babel/register')\nrequire('./app')\n```\n在入口文件头部引入 `@babel/register` 后，我们的 `app` 文件中即可使用任意 es2015 的特性。\n\n当然，坏处是动态编译，导致程序在速度、性能上有所损耗。\n\n## babel-node\n\n我们上面说，babel-register 提供动态编译，能够让我们的源代码真正运行在生产环境下 - 但其实不然，我们仍需要做部分调整，比如新增一个入口文件，并在该文件中 `require('@babel/register')`。而 babel-node 能真正做到一行源代码都不需要调整：\n\n```bash\n$ npm install --save-dev @babel/core @babel/node\n$ npx babel-node app.js\n```\n只是，请不要在生产环境中使用 babel-node，因为它是动态编译源代码，应用启动速度非常慢。\n\n## babel 7 迁移指南\n\n如果你需要从旧版本 babel 迁移到 babel 7，那么，请参照官方的 [babel 7 升级指南](https://babeljs.io/docs/en/v7-migration)。","isEmpty":false,"excerpt":"","stats":{"ctimeMs":1546997551058.7952},"author":"陈三","description":"","datePublished":1451643905000,"template":"post.js"},{"filePath":"_posts/best-practice-contribute-on-github.md","title":"如何在 Github 给开源项目贡献代码","date":"2014-09-16T22:44:55.000Z","permalink":"/best-practice-contribute-on-github/","tags":["Git","Github"],"content":"{:toc}\n\n“Fix typo” 算不算贡献？毫无疑问。\n\n好了，就在刚刚，你发现 Github 上某开源项目的一个标点错误，但这是你第一次尝试给开源项目贡献代码。你需要一点帮助，以便更好应对可能出现的种种意外。\n\n## 分叉\n\n首先，`Fork` 开源项目到自己 github 账户下，比如 `webpack/webpack` 到 `chenxsan/webpack`。\n\n## 克隆\n\n然后从 `chenxsan/webpack` 克隆代码到本地：\n\n```bash\n$ git clone https://github.com/chenxsan/webpack\n```\n\n## 分支\n\n进入克隆下来的代码目录，并创建一个分支：\n\n```bash\n$ cd webpack\n$ git checkout -b dev\n```\n这里的分支名为 `dev`，通常可以根据目的起一个更具体的分支名称，比如 `fix-typo`。\n\n## Fix typo\n\n在 `dev` 分支下修正问题，并 commit：\n\n```bash\n$ git commit -m 'Fix typo'\n```\n\n## 推送\n\n将本地 commit 推送到 github 上：\n\n```bash\n$ git push origin dev:fix-typo\n```\n我们将本地的 `dev` 分支推送到 github 上的 `fix-typo` 分支。\n\n## 提交 Pull request\n\n分支推送到 github 后，`chenxsan/webpack` 项目下就会出现 pull request 相关的按钮，提交给上游的 `webpack/webpack`，请求 Merge。\n\n## 意外\n\n但很不幸，因为一点其它问题，该 Pull request 被拒绝，项目管理员要求你调整后再提交 - 此时，上游 `webpack/webpack` 已经有新代码并入。\n\n问题来了：本地的 `dev` 分支所基于的 commit 已经不是最新。\n\n## 更新\n\n我们需要从上游更新代码。\n\n首先，配置上游库：\n\n```bash\n$ git remote add upstream https://github.com/webpack/webpack\n```\n然后切换至 `master` 分支更新上游代码：\n\n```bash\n$ git pull --rebase upstream master\n```\n接着再切换至 `dev` 分支，`rebase` 代码：\n\n```bash\n$ git rebase master\n```\n注意，如果你的 `dev` 分支有人使用的话，请谨慎使用 `rebase`，因为它会影响别人。\n\n## 再度推送\n\n修改完成后，我们可以再度推送代码到 github：\n\n```bash\n$ git push origin dev:fix-typo\n```\n但会推送失败 - 因为线上的 `fix-typo` 与线下的 `dev` 分支的 base 已经不一致。git 会提示我们先 pull、merge，但那样 commit 消息会很乱。\n\n我们可以选择粗暴的方案：\n\n```bash\n$ git push --force origin dev:fix-typo\n```\n为什么可行？因为基本不可能出现有人基于我们线上 `fix-typo` 分支的情况。\n\n## 清理分支\n\n在 pull request 被合并后，删除远程的 `fix-typo` 分支及本地 `dev` 分支\n\n```bash\n$ git push origin --delete fix-typo\n$ git branch -D dev\n```\n## 又及\n\n这里有几个重点。\n\n一个是保持 `master` 分支干净，不在 `master` 分支上 commit。这一条建议来自 [jQuery](http://contribute.jquery.org/commits-and-pull-requests/#never-commit-on-master)。目的是给自己方便：\n\n> This is really only for your own convenience: it&#8217;s easy for the maintainer of a project to accept your pull request from your master branch, but it&#8217;s problematic for your fork when you want to pull the changes back and your master branch has diverged from upstream.\n> \n> 这纯是为了你自己方便：对项目维护者来说，接受来自你 master 分支的 pull request 是很简单的事，但对你的分支来说，这会是个问题，比如你要从上游分支拉回修改，但是你的 master 分支却已经分道扬镳。\n\n整个过程中，我们的 `master` 分支只是为同步上游库而存在。\n\n另一个是[保持 commit 历史干净](http://ginsys.eu/git-and-github-keeping-a-feature-branch-updated-with-upstream/)。所以上面的流程中，拉回上游库的修改用了 `--rebase`，而不是先 fetch 再 merge。\n","isEmpty":false,"excerpt":"","stats":{"ctimeMs":1546997551058.926},"author":"陈三","description":"","datePublished":1410907495000,"dateModified":1410907495000,"template":"post.js"},{"filePath":"_posts/CentOS 常用 PostgreSQL 命令/index.md","date":"2016-08-09T04:56:31.000Z","title":"CentOS 常用 PostgreSQL 命令","permalink":"/centos-postgresql-command/","tags":["PostgreSQL"],"content":"{:toc}\n\n## 用户登录\n\nCentOS 7 安装完 PostgreSQL 后，默认会创建 `postgres` 用户。\n\n要使用 PostgreSQL，我们需要先切换到 `postgres` 用户：\n\n```bash\n$ sudo -i -u postgres\n```\n接着运行：\n\n```bash\n$ psql\n```\n\n进入 PostgreSQL 命令行。此时命令行提示不再显示 `$`，而是 `postgres=#`。\n\n现在就可以执行各种 SQL 语句。\n\n## 退出 PostgreSQL 命令行\n\n`\\q` 或 `\\quit`：\n\n```bash\npostgres=# \\q\n```\n\n## 查看所有数据库\n\n`\\l` 或 `\\list`：\n\n```bash\npostgres=# \\l\n```\n\n## 连接数据库\n\n`\\c` 或 `\\connect`：\n\n```\npostgres=# \\c test\n```\n\n## 查看表\n\n在连上数据库后，可以查看数据库下所有数据表：\n\n```bash\npostgres=# \\d\n```\n\n`\\d` 会罗列出所有的数据表，包括 PostgreSQL 自动创建的自增长字段的表。如果只想查看用户创建的表，\n\n```bash\npostgres=# \\dt\n```\n\n如果想查看单个数据表的结构，则在命令后指定表名：\n\n```bash\npostgres=# \\d test\n```\n\n附：[PostgreSQL 文档](https://www.postgresql.org/docs/current/static/app-psql.html)。","isEmpty":false,"excerpt":"","stats":{"ctimeMs":1546997551047.4587},"author":"陈三","description":"","datePublished":1470718591000,"dateModified":1470718591000,"template":"post.js"},{"filePath":"_posts/chrome 65 引入 seo audit/chrome-65-introduce-seo-audit.md","title":"Chrome 65 将引入 SEO 审计功能","date":"2018-02-06T00:00:00.000Z","permalink":"/chrome-65-introduce-seo-audit/","excerpt":"","tags":["chrome","新闻"],"content":"{:toc}\n\n显然，前端开发并不活在真空。很多时候，需要我们关心 SEO（搜索引擎优化）。有众多第三方网站、工具提供免费或收费的 SEO 审计功能，但现在，打开 Chrome 65 就有 - 来自 Google 官方的、免费的 SEO 审计。\n\n用法如下：\n\n1. 打开 Chrome 开发者工具，\n2. 选择 **Audit** 选项卡，\n3. 点击 **Perform an audit...**，\n4. 勾选 **SEO**，并点击 Run audit，\n5. 等待结果。\n\n![screenshot for seo audit](./chrome-65-introduce-seo-audit.gif)\n\n当然，目前审计的内容还比较基础，后期有望扩增更多功能。\n\nVia [Launching SEO Audit category in Lighthouse Chrome extension ](https://webmasters.googleblog.com/2018/02/seo-audit-category-in-lighthouse.html)\n\n\n","isEmpty":false,"stats":{"ctimeMs":1546997551061.7651},"author":"陈三","description":"","datePublished":1517875200000,"dateModified":1517875200000,"template":"post.js"},{"filePath":"_posts/Chrome 开发者工具分析内存使用情况/index.md","title":"Chrome 开发者工具分析页面内存使用情况","date":"2015-12-06T12:43:44.000Z","dateModified":1532563200000,"permalink":"/chrome-devtools-memory-profiling/","tags":["Chrome","JavaScript"],"content":"{:toc}\n\n> JavaScript 内存分析是个很大的话题，这里介绍些我的入门经验\n\n如果你在开发 JavaScript 应用时发现页面有明显的卡顿、甚至崩溃的状况，那么很可能内存泄露了。\n\n要怎么调查内存泄露的问题？从哪里开始？怎样一个步骤？\n\n## Chrome Task Manager\n\nChrome 内置了 Task Manager，类似 Windows 的任务管理器，它的打开方式见下图（截图中 Chrome 版本号为 68.0.3440.75）：\n\n![Open Chrome task manager](./open-chrome-task-manager.png)\n\n打开 Chrome 的 Task Manager 后，我们能看到当前打开的各个标签页的 JavaScript 内存使用情况：\n\n![chrome task manager memory usage](./chrome-task-manager.png)\n\n截图中 `JavaScript Memory` 一列有两个值，我们主要关心括号中的 live 数据 - 如果这个数值在增加，则表示可能有新对象创建了，又或者旧对象在膨胀。\n\n## Chrome 开发者工具\n\n当然，一边操作页面，一边盯着 Chrome Task Manager 人肉监控内存变化这事实在太落后了。\n\n我们有更好的办法。\n\n我们利用 Chrome 开发者工具的 Performance 面板来监控 Memory 变化：\n\n1.  打开 Chrome 开发者工具\n2.  点击 Performance 面板\n3.  勾选 Memory 选项\n4.  点击录制按钮\n5.  点击 `Collect garbage` 按钮回收内存\n6.  执行可疑操作\n7.  点击 `Collect garbage` 按钮回收内存\n8.  再次点击录制按钮，结束录制\n\n上面操作中，我们有两次点击 `Collect garbage`，这是为了排除可回收内存的影响。\n\n![Chrome 开发者工具监控内存变化](./chrome-devtools-memory.png)\n\n## 内存分析\n\n通过 Performance 面板，我们能够监控到内存变化的趋势，但具体是哪些代码引起的内存问题？则需要进一步借助 Chrome 开发者工具 Memory 面板下的两个内存分析助手：\n\n- Heap Snapshot\n- Allocation instrumentation on timeline\n\nHeap Snapshot 能够捕捉当前页面当下 JavaScript 及 DOM 节点的内存使用情况。比如我们想看看当前页面上是否有众多的 Detached DOM 存在，则可以捕捉一个快照，然后搜索 Detached DOM。\n\n当然，我们也可以创建多个快照，然后进行比对，看看哪些操作引发数据的增减，方便我们定位问题所在。\n\nAllocation instrumentation on timeline 可以纪录开启时段中内存分配与回收的情况。比如我们有一个操作，创建了大量的对象，则时间线上就会出现一个蓝条，框选蓝条，我们就能看到具体的内存分配状况。\n\n## 扩展阅读\n\n1.  [Fix Memory Problems](https://developers.google.com/web/tools/chrome-devtools/memory-problems/)\n2.  [视频：The Breakpoint Ep. 8: Memory Profiling with Chrome DevTools](https://www.youtube.com/watch?v=L3ugr9BJqIs)\n","isEmpty":false,"excerpt":"","stats":{"ctimeMs":1546997551048.6204},"author":"陈三","description":"","datePublished":1449405824000,"template":"post.js"},{"filePath":"_posts/css 三角形/index.md","title":"CSS 三角形","date":"2013-05-28T05:05:07.000Z","permalink":"/css-triangle/","tags":["CSS"],"content":"{:toc}\n\n网页设计里，我们经常看到三角形箭头。比如一个下拉框，会有一个向下、一个向上的三角形箭头。大部分人遇到这样的设计，第一反应可能是将三角形部分切成 PNG 透明图片。但其实我们可以用 CSS 代码来绘制三角形。\n\n来看一个示例：\n\n<div style=\"width:100px;\n    height:100px;\n    background-color:black;\n    border-top:50px solid red;\n    box-sizing: content-box;\">\n</div>\n\n上面是一个长、宽均为 100px 的 div，黑色背景，顶部边框 50px 宽，红色。它的 HTML 代码如下：\n\n```html\n<div style=\"width:100px;\n    height:100px;\n    background-color:black;\n    border-top:50px solid red;\n    box-sizing: content-box;\">\n</div>\n```\n我们增加一条 50px 的蓝色底部边框看看：\n\n<div style=\"width:100px;\n    height:100px;\n    background-color:black;\n    border-top:50px solid red;\n    border-bottom:50px solid blue;\n    box-sizing: content-box;\">\n</div>\n\n我想没有人对这样的显示效果有疑义。\n\n再加一条绿色的右边框会怎样？\n\n<div style=\"width:100px;\n    height:100px;\n    background-color:black;\n    border-top:50px solid red;\n    border-bottom:50px solid blue;\n    border-right:50px solid green;\n    box-sizing: content-box;\">\n</div>\n\n有意思的是，新增的右边框并不是长方形，而是梯形，它同时也影响与它相邻的上、下边框，导致它们从长方形变成直角梯形。\n\n为什么会这样？\n\n且假设新增的右边框是长方形，则我们会得到这样的样式：\n\n<div style=\"width:100px;\n    height:100px;\n    background-color:black;\n    border-top:50px solid red;\n    border-bottom:50px solid blue;position:relative;overflow:visible;\n    box-sizing: content-box;\">\n    <div style=\"width:50px;height:100px;position:absolute;top:0;right:-50px;background:green;\n    box-sizing: content-box;\"></div>\n</div>\n\n又或者下面这种：\n\n<div style=\"width:100px;\n    height:100px;\n    background-color:black;\n    border-top:50px solid red;\n    border-bottom:50px solid blue;position:relative;overflow:visible;\n    box-sizing: content-box;\">\n    <div style=\"width:50px;height:200px;position:absolute;top:-50px;right:-50px;background:green;\n    box-sizing: content-box;\"></div>\n</div>\n\n无论哪种长方形，效果都不理想。于是我们有了梯形这个选项，实际上，是两个边框可重叠部分沿对角线分割，各领一半，各上各色。不过很可惜，我没有找到任何相关的 CSS 规范或标准来佐证我的这个说法。\n\n接下来，我们再给上面的 div 补上橙色左边框：\n\n<div style=\"width:100px;\n    height:100px;\n    background-color:black;\n    border-top:50px solid red;\n    border-right:50px solid green;\n    border-bottom:50px solid blue;\n    border-left:50px solid orange;\n    box-sizing: content-box;\">\n</div>\n\n可以想像，缩减 div 块的宽 、高直到 0，我们的 div 会变成这样：\n\n<div style=\"width:0;\n    height:0;\n    background-color:black;\n    border-top:50px solid red;\n    border-right:50px solid green;\n    border-bottom:50px solid blue;\n    border-left:50px solid orange;\n    box-sizing: content-box;\">\n</div>\n\n此时，CSS 三角形生成的方法就非常明了。\n\n比如，我要用 CSS 实现向下箭头，则要不断减少下边框蓝色部分的宽度，直到 0 为止，\n\n<video src=\"./css-triangle.mp4\" controls width=\"200\"><video>\n\n最后将左、右边框的颜色设为透明：\n\n<div style=\"width:0;\n    height:0;\n    background-color:none;\n    border-left:50px solid transparent;\n    border-right:50px solid transparent;\n    border-bottom:none;\n    border-top:50px solid red;\n    box-sizing: content-box;\">\n</div>\n\n代码如下：\n\n```\n<div style=\"width:0;\n    height:0;\n    background-color:none;\n    border-left:50px solid transparent;\n    border-right:50px solid transparent;\n    border-bottom:none;\n    border-top:50px solid red;\n    box-sizing: content-box;\">\n</div>\n```\n其他方向的三角形箭头，向上，向左，或向右，同理均可以实现。\n","isEmpty":false,"excerpt":"","stats":{"ctimeMs":1547561395173.0508},"author":"陈三","description":"","datePublished":1369717507000,"dateModified":1369717507000,"template":"post.js"},{"filePath":"_posts/CSS 架构/index.md","title":"CSS 架构","date":"2013-08-22T23:35:51.000Z","excerpt":"","permalink":"/css-architecture/","tags":["CSS","翻译"],"content":"{:toc}\n\n> **声明**：本文译自 [CSS Architecture](https://philipwalton.com/articles/css-architecture/)。\n\n对大部分 Web 开发人员来说，精通 CSS 意味着你能够在代码中完美复现一个视觉模型。你没有使用表格，也尽少用到图片 - 对此你觉得自豪。如果你真的足够厉害，则你会用最新、最好的技术，比如媒体查询，过渡与转换。对优秀的 CSS 开发人员来说，这些都是必须，但在评估个人技能时，CSS 有一个方面很少被提及。\n\n有意思的是，其他语言里我们通常不会这样疏忽。一个 Rails 开发人员不会因为他的代码符合规范就被认为优秀。这是基本的。它当然要符合规范，然后才好评价其它方面：代码可读性如何呀？是否易于修改、易于扩展？跟程序的其它部分解藕度如何？扩展性如何？\n\n这些问题，在评估代码库其他部分时是理所当然要问的，CSS 也不应例外。今天的 web 应用程序比以往任何时候都要庞大，一个不经思考的 CSS 架构会削弱开发能力。是时候像评估程序其他部分那样去评估 CSS 了。可不能再事后再说，又或干脆撇为“设计师”的问题。\n\n## 优秀 CSS 架构的目标\n\n在 CSS 社区，想要就**最佳实践**取得共识可不容易。只要看看 [Hacker News 上的评论](https://news.ycombinator.com/item?id=2658948)及 [CSS Lint](http://csslint.net/) 释出后[开发者们的反应](https://2002-2012.mattwilcox.net/archive/entry/id/1054/)就应该知道，我们连最基本的、CSS 作者该的和不该的都没能取得一致看法。\n\n因此，我认为我们应该首先定义目标，而不是我为自己的一套最佳做法铺陈论点。如果我们在目标上达成一致，那么我们就有望检出糟糕的 CSS，但不是因为它打破我们先入为主的关于优秀的观念，而是因为它在阻碍开发进度。\n\n我相信优秀的 CSS 架构目标应该与所有优秀的软件开发目标一致。我希望我的 CSS 是可预见的，可复用的，可维护且可扩展的。\n\n### 可预见的\n\n可预见的 CSS 意味着你的规则不会给你惊吓。当你添加或更新一条规则，它不会影响到你没打算影响的网站部分。对不频繁更改的小网站来说，这不很重要，但对数十或数百页的大网站来说，可预见的 CSS 是一种必须。\n\n### 可重复使用\n\nCSS 规则应当是抽象的，解藕的，你可以从现有部分快速创建新组件，而不必重编码那些你已经解决的模式和问题。\n\n### 可维护的\n\n当你需要在网站上添加、更新或重新安排新组件和特性时，我们不需要重构现有 CSS。添加 X 组件到页面中不应该破坏 Y 组件。\n\n### 可扩展\n\n随着你的网站规模和复杂度不断增长，它通常需要更多开发者来维护。可扩展的 CSS 意味着，不论是一个人还是一个大的工程团队，都可以轻松管理。这也意味着，你的网站 CSS 架构平易近人，而不是一条陡峭的学习曲线。仅仅因为你是今天唯一接触 CSS 的开发者并不意味着接下来还是如此。\n\n## 常见的糟糕做法\n\n在我们了解优秀的 CSS 架构方法前，我觉得有必要先看看一些常见的糟糕做法，这对我们是有帮助的。通常只有通过反复的错误，我们才会开始拥抱其他方法。\n\n下面的例子，其实是我写过的代码的总结，虽然技术上没问题，但每一个都会导致灾难，让人头痛。这些模式过去一直让我陷入麻烦。尽管我意愿美好，并且承诺这一次一定会有所不同。\n\n### 基于父元素来修改组件\n\n互联网上，几乎每一个网站都会有一个视觉元素，每次出现都一个样，却总有一次例外。面对这种例外，几乎每一个新 CSS 开发人员（即使是有经验的）都用同样的处理方式。你为这一异类找到一个独有的父元素（或者你创建一个），然后写一个新规则来处理它。\n\n```css\n.widget {\n  background: yellow;\n  border: 1px solid black;\n  color: black;\n  width: 50%;\n}\n\n#sidebar .widget {\n  width: 200px;\n}\n\nbody.homepage .widget {\n  background: white;\n}\n```\n\n第一眼看去，这只是段无害代码，且让我们按上面确立的目标检查一下它。\n\n首先，例子中的小部件不可预见。创建这些部件的开发人员期望它们看起来都是某个样子，然而当他在侧边栏或主页上使用时，却发现它不一样，尽管标记完全相同。\n\n另外，它也不好复用或扩展。如果其它页面上也需要它，而且跟主页上的样子一样，会怎样？又要添加新规则。\n\n最后，它不易维护。如果小部件要重新设计，将要在好几个地方更新 CSS ，而且与上面的例子不同，这种反模式规则很少出现在一起。\n\n想像一下，如果这种类型的代码是在任何其他语言中出现。基本上，你就是先定义一个类，然后在另一部分代码，取得类的定义，然后基于某一特定用途做些修改。这直接违反开放/闭合的软件开发原则：\n\n> 软件实体（类，模块，函数等）应该对扩展开放，对修改闭合。\n\n在这篇文章后面，我们将来看看如何不依赖父选择符来修改组件。\n\n### 过于复杂的选择器\n\n互联网上不时就会出现一篇文章，展示 CSS 选择器的能力，并宣称，你可以不靠任何类或 ID 样式化整个网站。\n\n虽然技术上确实可行，但我接触的 CSS 越多，我就越会远离复杂的选择器。选择器越复杂，它跟 HTML 耦合度越高。依托 HTML 标签和组合的确可以让你的 HTML 干干净净，但结果是你的 CSS 又臃肿又杂乱。\n\n```css\n#main-nav ul li ul li div {\n}\n#content article h1:first-child {\n}\n#sidebar > div > h3 + p {\n}\n```\n\n所有上述例子逻辑上均合理。第一个可能是在样式化下拉菜单，第二个说的是文章主标题看起来应该跟所有其他 h1 元素不同，最后一个例子好像是给侧边栏部分的第一段落增加些额外间距。\n\n如果这 HTML 永远不变，这种说法还有可取之处，但 HTML 一直不变本身就很不现实。复杂的选择器让人印象深刻，它们可以从 HTML 中分离出表现，但它们很少有助于实现我们的目标 - 优秀的 CSS 架构。\n\n上面这些例子全是不能复用的。因为选择器指向的是标记中某一特殊地方，另一组件因为 HTML 结构不同，也就没法复用那些样式。举第一个选择器（下拉）为例，如果类似的下拉需要在不同页面出现，并且它还不在 `#main-nav` 元素里，我们该怎么办？你只能重建整个样式。\n\n一旦 HTML 需要改变，这些选择器也变得难以预见。想像一下，如果某个开发者想把第三个例子中的 div 标签改成 HTML5 的 section 标签，整条规则就废了。\n\n因为这些选择器只有在 HTML 保持不变时方有效，他们显然不可维护、不可扩展。\n\n在大型应用中，你需要权衡然后做出妥协。以保持 HTML “干净”的名，换来复杂选择器的脆弱，其实并不值得。\n\n### 过于通用的类名称\n\n创建可复用的视觉组件时，组件的子元素置入组件类名的作用域中是很通用的做法。例如：\n\n```html\n<div class=\"widget\">\n  <h3 class=\"title\">...</h3>\n  <div class=\"contents\">\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit.\n    In condimentum justo et est dapibus sit amet euismod ligula ornare.\n    Vivamus elementum accumsan dignissim.\n    <button class=\"action\">Click Me!</button>\n  </div>\n</div>\n```\n\n```css\n.widget {\n}\n.widget .title {\n}\n.widget .contents {\n}\n.widget .action {\n}\n```\n\n我们的想法是，`.title`、`.contents`、`.action` 这些子元素类可以安全地样式化，而不必担心这些样式会溢出到任何其他同名类元素中。确实如此，但它同样不能阻止同一类名的样式渗入。\n\n在一个大项目中，像 `.title` 这样的类名会经常出现，可能是在另一个上下文，甚至自身中。如果这种情况发生，部件的标题就会跟预想的不同。\n\n过于通用的类名会导致难以预测的 CSS。\n\n### 一个规则做太多事情\n\n有时候，你会创建一个视觉组件，离网站某部分左边、上边均 20px：\n\n```css\n.widget {\n  position: absolute;\n  top: 20px;\n  left: 20px;\n  background-color: red;\n  font-size: 1.5em;\n  text-transform: uppercase;\n}\n```\n\n然后在后面，你需要在不同位置使用这一组件。上述 CSS 代码将无法正常使用，因为它在不同上下文中无法复用。\n\n问题就在于，你让这个选择器做太多事了。在一条规则里，你定义了外观和风格，还定义了布局和位置。外观和风格是可重复使用的，但布局和位置不是。因为它们是一起用的，整个规则就像个妥协结果。\n\n虽然第一眼看上去，这可能无害，但它通常会导致不熟练的 CSS 开发者不断复制粘贴。如果一个团队新成员想要某样东西，它看起来像某一组件，比如说 `.infobox`，他们可能会先尝试该类。但是，那行不通的，因为新 infobox 会以不一样的方式定位，你觉得他们接下来可能做什么？在我的经验中，大多数新开发人员都不会把规则破开，整理成可复用的部分。相反，他们会创建一个新选择器，把这一特定实例需要的代码复制、粘贴进来，结果就不必要地重复了代码。\n\n## 原因\n\n所有上述问题都有一个共性，他们把过多样式化的责任交给了 CSS。\n\n这说法看似奇怪。毕竟，它是一个样式表，它难道不该承担大部分（如果不是全部）的样式化工作？这不正是我们想要的吗？\n\n对这个问题的简单答案是“是的”，但是，像往常一样，事情并不总是那么简单。内容与表现分离是件好事，但就因为你从 HTML 中分离出 CSS，并不意味着你的内容就和表现分离了。换句话说，从 HTML 代码中分拆出所有表现代码并没有实现我们的目标，因为我们的 CSS 要正常工作，需要非常了解 HTML 结构。\n\n此外，HTML 很少只是内容，它几乎总也是结构。而往往这种结构包含一些容器元素，它们没有其他目的，仅仅是让 CSS 独立出一组特定元素。即使没有表现的类，这仍明显是表现与 HTML 的混合。但是否有必要把表现混入内容？<!--这一段有些不明白-->\n\n我相信，基于 HTML 和 CSS 的当前状况，让它们共同努力一同担当表现层的工作是必要且明智的。内容层仍然可以通过模板和 partials 抽象出。\n\n## 解决办法\n\n既然你的 HTML 和 CSS 要一同合作来搭建 web 应用程序表示层，他们就需要一个方法来实践所有优秀的 CSS 架构原则。\n\n我发现的最好办法是，CSS 里尽可能少包括 HTML 结构。CSS 应该定义一组视觉元素的外观（以减少与 HTML 的耦合度），这些元素不论出现在 HTML 的哪里，都应该是那个样子。如果某个组件在不同情况下需要不同外观，它应该被定义成其他东西，应用它则是 HTML 的责任。\n\n举个例子， CSS 可能通过 `.button` 类定义一个按钮组件。如果 HTML 想要一个特定元素，看起来像个按钮，它就应该使用这个类。如果有些情况需要不同的按钮（比如大点的，或是全宽度的），那么 CSS 需要一个新类来定义外观，然后，HTML 应用新类，来布置新外观。\n\nCSS 定义你的组件是什么样子，HTML 则将这些样式配给页面元素。CSS 需要了解的 HTML 结构越少，结果会越好。\n\n在 HTML 中明确声明你的需要，会有一个很大的好处，它可以让其他查看标签的开发人员确切知道什么元素应该是什么样子。意图是显而易见的。如果不是这种做法，就很难区分元素的外观是有意还是无意的，这给团队带来困惑。\n\n一种常见的反对声音是说，标签中加入许多类会导致有很多工作要做。一条 CSS 规则可以针对特定组件的一千个实例，那么有什么值得我们为了在标签中明确声明去书写一千次的类名？\n\n虽然这种担忧是有的，它却可能会误导。它的言下之意是，或者你在 CSS 中使用父选择器，或者你手写 1000 次 HTML 类，但我们显然有其他替代方法。Rails 或者其他框架中的视图层的抽象，可以在保持明确声明外观的同时无需在 HTML 里重复写同一类。\n\n## 最佳实践\n\n在我犯过一遍又一遍的上述错误并付出代价后，我得出了以下建议。虽然并不全面，但我的经验表明，坚持这些原则将有助你更好地实现优秀的 CSS 架构目标。\n\n### 目的明确\n\n要确保你的选择器不会误操作其它元素的最好方法，是不给它们机会。`#main-nav ul li ul li div` 这样的选择器，很容易就会在你更改标签过程中误样式化其他元素。而 `.subnav` 这样的样式，绝不会无意样式化意外元素。给你想要样式化的元素应用类是最好的方式，这样可以保持你的 CSS 可预见。\n\n```css\n/* Grenade */\n#main-nav ul li ul { }\n\n/_ Sniper Rifle _/\n.subnav { }\n```\n以上两个例子，你可以想像第一个是手榴弹，第二个则是狙击枪。手榴弹今天可能工作得很好，但你永远不知道，什么时候无辜平民会进入到爆炸范围内。\n\n### 分离关注点\n\n我已经提到过，一个组织良好的组件层可以帮解耦 CSS 与 HTML 结构。此外，你的 CSS 组件本身应该是模块化的。组件应该知道如何样式化自己，并且能把样式化工作做好，但它们不应该负责它们的布局或位置，也不应该对他们将如何与周围元素间隔开这种事做太多假设。\n\n总的来说，组件应该定义它们的外观，而不是布局或位置。当你看到位置，宽度，高度和边距与背景，颜色，字体等属性出现在同一规则里时，就要小心了。\n\n布局和位置，应该由一个独立的布局类或单独的容器元素处理。（请记住，要有效分离内容与表现，往往要求把内容从容器中分开。）\n\n### 命名空间类\n\n我们已经研究了为什么父选择器在封装和防止样式交叉污染时不是100%有效的。一个更好的方法是应用命名空间到类上。如果一个元素是视觉组件一员，则每个子元素类都应该使用组件基类名称作为命名空间。\n\n```css\n/* High risk of style cross-contamination */\n.widget { }\n.widget .title { }\n\n/_ Low risk of style cross-contamination _/\n.widget { }\n.widget-title { }\n```\n\n给你的类加上命名空间，可以让你的组件自包含、模块化。它最大限度地减少现有类发生冲突的可能性，并降低样式化子元素需要的特殊性。\n\n### 通过修饰类来扩展组件\n\n当现有的组件在不同上下文中略有不同时，创建一个修饰类来扩展它。\n\n```css\n/* Bad */\n.widget { }\n#sidebar .widget { }\n\n/_ Good _/\n.widget { }\n.widget-sidebar { }\n```\n\n我们已经看到基于组件父元素之一修改组件的缺点，但这里需要说一下：修饰类可应用到任何地方。基于位置的覆写只能在特定位置使用。修饰类则可以根据你的需要任意使用。最后，修饰类在 HTML 中清楚表达了开发者的意图。基于位置的类却相反，如果开发者只是查看 HTML，则基于位置的类根本不可见，大大增加被忽略的概率。\n\n### 按逻辑结构组织你的 CSS\n\n[Jonathan Snook](https://snook.ca/) 在他的优秀著作 [SMACSS](https://smacss.com/) 里建议把 CSS 规则分为​四个不同类别：基础，布局，模块，和状态。基础由重置规则和元素缺省值组成。布局用于定位跨站元素，还包含通用布局方式如网络系统。模块是可重复使用的视觉元素，状态则指可以通过 JavaScript 开启或关闭的样式。\n\n在 SMACSS 系统中，模块（相当于我说的组件）包括 CSS 规则的绝大多数，因此我觉得常常有必要进一步分割，抽象到模板中。\n\n组件是独立的视觉元素。模板却是构建使用的基础块。模板无法自代表，也很少描述外观和风格。相反，它们是单一，可重复的模式，可以放在一起，形成一个组件。\n\n举个具体的例子，一个组件可能是一个模式对话框。对话框在头部可能有网站的背景渐变标识，围绕它可能有一个阴影，在右上角可能有一个关闭按钮，它可能被固定定位，水平和垂直均居中。这四种模式中的每一个都可能在整站中一次又一次地用到，这样你就不必每次都重新编写这些模式。他们都是模板，一起则构成组件。\n\n我通常不在 HTML 中使用模板类，除非我有一个很好的理由。相反，我使用一个预处理器在组件定义中引入模板样式。我将在后面详细讨论我这样做的理由。\n\n### 使用类来样式化并且只用来样式化\n\n无论谁，如果在大型项目上工作过，就可能遇到一个 HTML 元素有这么一个类，类的目的完全未知。你想删除它，但你很犹豫，因为它可能有些你不知道的用处。这样的事一次又一次的发生，然后，随着时间推移，你的 HTML 中充满了不起任何作用的类，只因为团队成员都不敢删除它们。\n\n问题就在于，前端 web 开发中，类通常都被赋予太多责任。他们样式化 HTML 元素，他们扮演 JavaScript 钩子，他们加入到 HTML 中用于功能检测，他们用于自动化测试等等。\n\n这是问题。当类被应用程序的大部分用到，要想把它们从 HTML 中移除就会变得相当可怕。\n\n然而，确立一个惯例就可以完全避免这个问题。在 HTML 中，当你看到一个类，你应该能够立即说出它的目的是什么。我的建议是给所有非样式化目的的类加上前缀。比如我用 `.js-`， 前缀表示用于 JavaScript 目的，`.supports-` 则表示 Modernizr 类。所有不带前缀的类用于样式且只用于样式。\n\n这使得查找并移除未使用的类变得简单，就好像搜索样式表目录一样了。你甚至可以在 JavaScript 中自动完成这一过程，只要交叉引用 HTML 中的类与 `document.styleSheets` 对象的类。不在 `document.styleSheets` 中的类，可以安全删除。\n\n总的来说，内容从表现区分开是最佳实践，功能跟表现分离同样重要。使用样式化的类做 JavaScript 勾子会高度藕合你的 CSS 和 JavaScript，结果会很难或不可能在不破坏功能的情况下更新某些元素的外观。\n\n### 使用逻辑结构命名你的类\n\n当下，大多数人写 CSS 用连字符分隔词。但单独的连字符通常并不足以区分不同类型的类。\n\n[Nicolas Gallagher](http://nicolasgallagher.com/) 最近写了一篇，内容是[他如何解决这个问题](http://nicolasgallagher.com/about-html-semantics-front-end-architecture/)，我对他的办法略加修改然后应用，取得了不错的结果。为描述命名约定的必要，请看看以下：\n\n```css\n/* A component */\n.button-group { }\n\n/_ A component modifier (modifying .button) _/\n.button-primary { }\n\n/_ A component sub-object (lives within .button) _/\n.button-icon { }\n\n/_ Is this a component class or a layout class? _/\n.header { }\n```\n\n如果只是看上面的类，很难区分它们分别应用于哪一类规则。这不仅增加开发过程中的混乱，也使得你很难自动化测试你的 CSS 和 HTML。一个结构化的命名惯例，让你看到一个类名就确切地知道它与其他类的关系以及它应该出现在 HTML 的哪里 - 也使得命名更容易，此前并不能的测试变得可行。\n\n```sass\n/* Templates Rules (using Sass placeholders) */\n%template-name\n%template-name--modifier-name\n%template-name__sub-object\n%template-name__sub-object--modifier-name\n\n/_ Component Rules _/\n.component-name\n.component-name--modifier-name\n.component-name**sub-object\n.component-name**sub-object--modifier-name\n\n/_ Layout Rules _/\n.l-layout-method\n.grid\n\n/_ State Rules _/\n.is-state-type\n\n/_ Non-styled JavaScript Hooks _/\n.js-action-name\n```\n\n第一个例子重写：\n\n```css\n/* A component */\n.button-group { }\n\n/_ A component modifier (modifying .button) _/\n.button--primary { }\n\n/_ A component sub-object (lives within .button) _/\n.button\\_\\_icon { }\n\n/_ A layout class _/\n.l-header { }\n```\n\n## 工具\n\n保持一个有效、有组织的 CSS 架构是非常困难的，尤其是在大型团队里。一些这或那的不良规则，可以越滚越大，直到变成一个不可收拾的烂摊子。一旦你的应用程序 CSS 进入特殊性战争的地步，并且只能靠着出 `!important` 这张王牌，它不从头开始也就基本无法恢复。关键是从一开始就要避免这些问题。\n\n幸运的是，有一些工具可以让控制你的网站 CSS 架构变得简单。\n\n### 预处理器\n\n这些日子里，谈 CSS 工具而不提预处理器是不可能的，因此本文也不例外。但在我赞美它们的有用之前，我应提醒几句。\n\n预处理器帮助你更快地编写 CSS，而不是更好。因为最终它被变成纯 CSS，应此也适用同样规则。既然预处理器能让你更快地写 CSS，那么它也可以让你更快地写糟糕的 CSS，所以在考虑一个预处理解决你的问题前，重要的是要先明白优秀的 CSS 架构。\n\n许多所谓的预处理器“特性”实际上对 CSS 架构非常不好。以下是一些“特性”，我尽可能要避免（虽然总体思路适用于所有预处理语言，以下这些指南特指 Sass）。\n\n- 如果只是为组织代码，决不要嵌套规则。只有当输出的 CSS 是你想要的时才嵌套。\n- 如果不传递参数，切勿使用 mixin。不带参数的 mixins 不如使用模板代替，它们是可扩展的。\n- 如果选择器并非单一类，则切勿使用 `@extend`。从设计的角度看，它毫无道理，而且它使编译后的 CSS 膨大。\n- 在组件修饰符规则中，切勿为 UI 组件使用 `@extend`，因为你失去了继承链（这个问题后面会聊得更多）。\n\n  预处理器最好的部分，是一些函数如 <a href=\"http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#extend\">@extend</a> 和 <a href=\"http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#placeholder_selectors_\">%placeholder</a>。两者都能让你轻松管理 CSS 抽象，而不添加多余东西，也不会在你的 HTML 中添加大量基类，这些基类相当难管理。\n\n  使用 `@extend` 时应特别注意，因为有时你会想在你的 HTML 中添加那些类。例如，当你第一次了解 `@extend`，你很容易就在你所有修饰类中这样使用：\n\n```sass\n.button {\n  /* button styles */\n}\n\n/_ Bad _/\n.button--primary {\n@extend .button;\n/_ modification styles _/\n}\n```\n\n这样做的问题是，在HTML中，你失去了继承链。这下，用 JavaScript 来选择所有按钮实例变得很难。\n\n一般来说，我决不扩展 UI 组件或任何我后来可能会想知道类型的东西。这是模板的用处，也是另一种帮助区分模板和组件的方式。在你的应用程序逻辑中，你不会需要针对模板，因此可以安全地使用预处理器扩展它。\n\n拿上面提到的模式对话框来说，它看起来可能是这样：\n\n```sass\n.modal {\n  @extend %dialog;\n  @extend %drop-shadow;\n  @extend %statically-centered;\n  /* other modal styles */\n}\n\n.modal**close {\n@extend %dialog**close;\n/_ other close button styles _/\n}\n\n.modal\\_\\_header {\n@extend %background-gradient;\n/_ other modal header styles _/\n}\n```\n\n### CSS Lint\n\n<a href=\"http://www.stubbornella.org/content/\">Nicole Sullivan</a> 和 <a href=\"http://www.nczonline.net/\">Nicholas Zakas</a> 创建了 <a href=\"http://csslint.net/\">CSS Lint </a>，一个代码质量检查工具，帮助开发人员检测他们的 CSS 坏习惯。他们的网站这样介绍：\n\n> CSS Lint 指出你的 CSS 代码问题。它检查基本语法，并且对代码应用一组规则，查找有问题的模式或效率低下的地方。规则都是可插拔的，因此你可以轻松编写自己的，或是忽略那些你不想要的规则。\n\n虽然一般的规则集对于大多数项目可能并不完美，CSS Lint 最大的特点是它有能力根据你的需要进行定制。这意味着你可以从他们的默认列表中挑出你想要的，也可以编写自己的。\n\n像 CSS Lint 这样的工具，在任何大型团队中都是必不可少的，这可以确保一致和惯例。也正像我在前面提到的，约定伟大的地方是，他们允许像 CSS Lint 这样的工具轻易识别出问题。\n\n基于我上面提出的约定，要编写规则来检查反模式就很容易。这里有我使用的几个建议：\n\n- 不要在你的选择器中使用 ID。\n- 任何多部分规则都不要使用非语义类型选择（如 DIV，SPAN）。\n- 不要使用超过2个组合的选择器。\n- 不要允许任何 “js” 开头的类名。\n- 非 “l-” 前缀的规则经常使用布局和定位则给出警告。\n- 如果一个类后来作为一个其他东西的子类重新定义，则给出警告。\n\n这些显然只是建议，但他们的主要目的，就是让你思考你的项目要如何加强标准。\n\n### HTML Inspector\n\n早些时候，我提到，要找出 HTML 中用到却不曾在任何样式表中定义的类是很容易的。我目前正在开发一个工具叫做 <a href=\"https://github.com/philipwalton/html-inspector\">HTML Inspector</a> ，它让这个过程更简单。\n\nHTML Inspector 遍历你的 HTML（很像 CSS Lint），允许你编写自己的规则，在一些惯例被打破时抛出错误和警告。我目前使用以下规则：\n\n- 如果相同 ID 不止一次出现​​在页面上，抛出警告。\n- 不使用任何样式表中没有的类，白名单（如 “js-” 前缀的类）里的也不使用。\n- 修饰类不应该离开它们的基类使用。\n- 如果祖先中不包含基类，则不要使用次对象类\n- 普通的 DIV 或 SPAN 元素，不附带任何类的话，不应该用在 HTML 中。\n\n## 总结\n\nCSS 不只是视觉设计。不要因为你写的是 CSS，就丢掉编程最佳实践。像 OOP，DRY，开放/闭合的原则，关注点分离等概念仍然适用于 CSS。\n\n我们的底线是，无论如何组织代码，请确保判断方法的标准是，它们是否在长远上，真正让你的开发变得更加简单、易于维护。\n","isEmpty":false,"stats":{"ctimeMs":1546997551047.1577},"author":"陈三","description":"","datePublished":1377214551000,"dateModified":1377214551000,"template":"post.js"},{"filePath":"_posts/dependencies 与 devDependencies 的区别/index.md","title":"区别 dependencies、devDependencies","author":"陈三","toc":false,"permalink":"/difference-between-dependencies-and-devdependencies/","date":"2014-05-05T17:36:09.000Z","tags":["npm"],"content":"\n我们在执行 `npm install` 安装依赖时，通常都会将依赖的名称、版本要求写入 `package.json` 文件。\n\n其中有两个命令行参数：\n\n1. `--save-prod` 将依赖的名称、版本要求写入 dependencies\n2. `--save-dev` 将依赖的名称、版本要求写入 devDependencies\n\n从命令行参数字面上，我们就能看出 dependencies、devDependencies 的区别：dependencies 表示我们要在生产环境下使用该依赖，devDependencies 则表示我们仅在开发环境使用该依赖。\n\n举个例子，我要用 `webpack` 构建代码，所以在开发环节，它是必需的，但对普通用户来说，它是不必要的，所以安装 `webpack` 时，我要执行：\n\n```bash\nnpm install webpack --save-dev\n```\n而不是：\n\n```bash\nnpm install webpack --save-prod\n```\n不过，在 [npm 5 发布](http://blog.npmjs.org/post/161081169345/v500)以前，答案并没有这么直观。\n\n在 npm 5 发布以前，我们执行 `npm install` 后，npm 只会下载依赖到当前目录的 `node_modules`，并不会在 `package.json` 中写入依赖的信息。\n\n那时我们也有两个参数可以使用：\n\n  1. `--save` 将依赖的名称、版本要求添加到 dependencies\n  2. `--save-dev` 将依赖的名称、版本要求添加到 devDependencies\n\n显然，`--save` 与 `--save-dev` 的区别远不如 `--save-prod` 与 `--save-dev` 这么清楚。\n\n或许 npm 该考虑把 dependencies 改成 prodDependencies，这样就能减少误会。\n","isEmpty":false,"excerpt":"","stats":{"ctimeMs":1546997551062.8599},"description":"","datePublished":1399311369000,"dateModified":1399311369000,"template":"post.js"},{"filePath":"_posts/Emmet.vim 教程/index.md","title":"Emmet.vim 教程","date":"2012-05-31T10:03:03.000Z","permalink":"/zencoding-vim-tutorial-chinese/","excerpt":"","tags":["vim","zencoding.vim","emmet.vim"],"content":"{:toc}\n\nEmmet 项目原来叫 Zen Coding，2012 年改名为 Emmet。\n\nEmmet 官方支持[很多编辑器](http://emmet.io/download/)，但 [Emmet.vim](https://github.com/mattn/emmet-vim/) 不是 Emmet 亲生，它是日本 [Yasuhiro Matsumoto](http://mattn.kaoriya.net/) 开发。\n\n## 下载 Emmet.vim\n\n你可以从 [Vim 插件站点](http://www.vim.org/scripts/script.php?script_id=2981)下载最新压缩包。\n\n## 安装 Emmet.vim\n\n将下载的压缩包解压到用户主目录的 `.vim` 目录下即可：\n\n```bash\ncd ~/.vim\nunzip emmet-vim.zip\n```\n\n不过，我会推荐使用 [pathogen.vim](http://www.vim.org/scripts/script.php?script_id=2332)  或是 [Vundle](https://github.com/VundleVim/Vundle.vim) 来管理 Vim 插件，具体用法可以查看它们的文档。\n\n## 使用 Emmet.vim\n\n**说明**：本着 Don't repeat yourself 的原则，下面的内容中除非特别说明，**调用快捷键**均指按下 <**Ctrl-y**\\>。\n\n### 展开\n\nEmmet 最大的意义，在于四两拨千斤：输入几个简短词组，调用快捷键，就可以输出我们想要的大块代码。\n\n我们试试在 Vim 下输入 `div>p#foo$*3>a`，接着调用快捷键，再按 `,`：\n\n```html\n<div>\n    <p id=\"foo1\">\n        <a href=\"\"></a>\n    </p>\n    <p id=\"foo2\">\n        <a href=\"\"></a>\n    </p>\n    <p id=\"foo3\">\n        <a href=\"\"></a>\n    </p>\n</div>\n```\n\nCool。`div`、`p`、`#foo`、`a` 以及 `>` 这些我们都认识，就是 CSS 选择器。那么 `$*3` 是什么？从展开结果我们可以猜出，`*3` 表示要输出三个 `p`，`$` 则表示自增长数字。更多说明可以查看 [Emmet 上的缩略语文档](https://docs.emmet.io/abbreviations/syntax/#abbreviations-syntax)。\n\n### 包围\n\n如下内容：\n\n```html\n    test1\n    test2\n    test3\n```\n\n首先定位到 `test1` 一行，然后按 `V` 进入 Vim 可视模式，再按 `3j` “行选取”三行内容，然后调用快捷键，并按 `,`，这时 Vim 的命令行会提示 `Tags:`，键入`ul>li*`，然后回车，结果如下：\n\n```html\n<ul>\n    <li>test1</li>\n    <li>test2</li>\n    <li>test3</li>\n</ul>\n```\n\n如果输入的 tag 是 `blockquote`，则会是以下结果：\n\n```html\n<blockquote>\n    test1\n    test2\n    test3\n</blockquote>\n```\n\n### 插入模式下根据光标位置选中整个标签\n\n这个过程共两步：\n\n1. 按 `i` 或 `a` 进入 Insert 模式\n2. 按 <**Ctrl-y**\\>，再按 d 键，选中光标所处的整个标签\n\n具体操作可以看下方视频：\n\n<video controls src='./balance-tag-inward.mp4'></video>\n\n不过这里会有一个问题，光标的位置在哪里才算对？拿视频中的代码来说：\n\n```html\n<div>\n        <ul>\n                <li><a href=\"|\"></a></li>\n                <li><a href=\"\"></a></li>\n                <li><a href=\"\"></a></li>\n        </ul>\n</div>\n```\n我们的光标是在 `|` 所处的位置。如果放到 `<|li>` 这里呢？你可以试试。\n\n### 跳转到下一个编辑点\n\n插入模式下调用快捷键，再按 `n` 键。\n\n可是，什么是编辑点？仍拿上面的代码来标注：\n\n```html\n<div>\n        <ul>\n                <li><a href=\"|\">|</a></li>\n                <li><a href=\"|\">|</a></li>\n                <li><a href=\"|\">|</a></li>\n        </ul>\n</div>\n```\n`|` 标注出我们的编辑点，通常是标签属性或标签的内容区域。\n\n### 跳转到上一个编辑点\n\n插入模式下调用快捷键，再按 `N`。\n\n### 插入图片大小\n\n移动光标到 img 标签。\n\n```html\n<img src=\"foo.png\" />\n```\n\n然后调用快捷键，再按 `i`：\n\n```html\n<img src=\"foo.png\" width=\"32\" height=\"48\" />\n```\n\n说明：仅适用本地图片，互联网上的图片无法取得其大小。\n\n### 合并行\n\n假设有这么一段代码：\n\n```html\n<ul>\n  \t<li class=\"list1\"></li>\n  \t<li class=\"list2\"></li>\n  \t<li class=\"list3\"></li>\n</ul>\n```\n我们想把三个 `li` 合并成一行。\n\n1. 选中三行\n2. 调用快捷键，再按 `m`\n\n我们得到了：\n\n```html\n<ul>\n  \t<li class=\"list1\"></li><li class=\"list2\"></li><li class=\"list3\"></li>\n</ul>\n```\n\n### 移除标签对\n\n如下代码：\n\n```html\n<div class=\"foo\">\n    <a>cursor is here</a>\n</div>\n```\n光标移动到 `a` 标签内，然后在普通模式下调用快捷键并按 `k`，就会移除 a 标签对：\n\n```html\n<div class=\"foo\">\n\n</div>\n```\n\n再操作一次的话，则连 `div` 标签块都被移除。\n\n### 注释\n\n移动光标到块中\n\n```html\n<div>\n    hello world\n</div>\n```\n\n插入模式下调用调用快捷键并按 `/`，就会注释掉整个 `div`：\n\n```html\n<!-- <div>\n    hello world\n</div> -->\n```\n\n再次操作则会取消注释。\n\n当然，你也可以在普通模式下操作。\n","isEmpty":false,"stats":{"ctimeMs":1546997551055.5186},"author":"陈三","description":"","datePublished":1338458583000,"dateModified":1338458583000,"template":"post.js"},{"filePath":"_posts/Firebase 托管静态博客/index.md","title":"Firebase 托管静态博客","date":"2018-07-30T00:00:00.000Z","dateModified":1534176000000,"permalink":"/firebase-hosting-static-site/","tags":["firebase","教程"],"content":"{:toc}\n\n我的博客就是些静态 HTML 文件，一向都部署在自建的 VPS 上，但最近觊觎 CDN 的速度，于是调查一番，选了 firebase 来托管博客。\n\nfirebase 提供的免费托管特性如下：\n\n1. 可存储的免费空间为 1 GB\n2. 每个月免费流量为 10 GB\n3. 可免费自定义域名，并配有免费 SSL 证书（Let's Encrypt）\n4. 免费 CDN\n5. 可回滚的部署历史记录 - 犯错也不怕\n\n对我这样每个月不过几千访问量的博客来说，firebase 的免费档应该是绰绰有余。一旦出现不够用的情况，还可以考虑 Blaze 方案 - 即用即付。\n\n## 创建项目\n\n首先登录 [https://console.firebase.google.com](https://console.firebase.google.com) 创建一个新项目。注意，创建过程中页面会默认生成一个 Project ID，我们也可以自己填写，它将决定我们的网站托管在 firebase 上的子域名，比如你填入 `google`，则最后你的博客将托管在 google.firebase.com 域名 - 只不过一旦创建后就不能再修改。\n\n## 安装 Firebase 命令行工具\n\n我们需要预先安装 `firebase-tools`，这是一个基于 Node.js 的工具包，我们需要通过 `npm` 或是 `yarn` 来安装：\n\n```bash\n$ yarn global add firebase-tools\n```\n\n安装完成后，命令行下就有 `firebase` 命令供差遣。\n\n## firebase login\n\n在终端窗口执行 `firebase login`，浏览器会自动打开一个请求授权的网址，但这个网址授权后会跳到 `localhost` 地址，就我经历来说，挂了代理后，这个地址跳不动。\n\n所以要换成如下命令：\n\n```bash\n$ firebase login --no-localhost\n```\n\n这样授权后不会跳到 `localhost`，而是返回一串 token，将该 token 拷入命令行回车即可完成登录。\n\n## 初始化 firebase\n\n命令行下登录 firebase 后，切换到博客根目录，初始化：\n\n```bash\n$ cd blog.zfanw.com\n$ firebase init\n\n     🔥🔥🔥🔥🔥🔥🔥🔥 🔥🔥🔥🔥 🔥🔥🔥🔥🔥🔥🔥🔥  🔥🔥🔥🔥🔥🔥🔥🔥 🔥🔥🔥🔥🔥🔥🔥🔥     🔥🔥🔥     🔥🔥🔥🔥🔥🔥  🔥🔥🔥🔥🔥🔥🔥🔥\n     🔥🔥        🔥🔥  🔥🔥     🔥🔥 🔥🔥       🔥🔥     🔥🔥  🔥🔥   🔥🔥  🔥🔥       🔥🔥\n     🔥🔥🔥🔥🔥🔥    🔥🔥  🔥🔥🔥🔥🔥🔥🔥🔥  🔥🔥🔥🔥🔥🔥   🔥🔥🔥🔥🔥🔥🔥🔥  🔥🔥🔥🔥🔥🔥🔥🔥🔥  🔥🔥🔥🔥🔥🔥  🔥🔥🔥🔥🔥🔥\n     🔥🔥        🔥🔥  🔥🔥    🔥🔥  🔥🔥       🔥🔥     🔥🔥 🔥🔥     🔥🔥       🔥🔥 🔥🔥\n     🔥🔥       🔥🔥🔥🔥 🔥🔥     🔥🔥 🔥🔥🔥🔥🔥🔥🔥🔥 🔥🔥🔥🔥🔥🔥🔥🔥  🔥🔥     🔥🔥  🔥🔥🔥🔥🔥🔥  🔥🔥🔥🔥🔥🔥🔥🔥\n\nYou're about to initialize a Firebase project in this directory:\n\n  /Users/sam/Documents/githubRepos/blog.zfanw.com\n\n? Which Firebase CLI features do you want to setup for this folder? Press Space to select features, then Ente\nr to confirm your choices. (Press <space> to select)\n❯◯ Database: Deploy Firebase Realtime Database Rules\n ◯ Firestore: Deploy rules and create indexes for Firestore\n ◯ Functions: Configure and deploy Cloud Functions\n ◯ Hosting: Configure and deploy Firebase Hosting sites\n ◯ Storage: Deploy Cloud Storage security rules\n```\n\n因为我们只是要托管静态博客，所以选择 `Hosting: Configure and deploy Firebase Hosting sites`。\n\n稍后会让我们关联一个 Firebase 项目，选择我们在 firebase 后台新建的项目。\n\n再往后则是：\n\n```bash\n? What do you want to use as your public directory? (public)\n```\n\n因为我的静态博客在构建后是放在 `dist` 目录的，所以这里我填入 `dist` - 默认为 `public` 目录。\n\n最终，`firebase init` 命令会生成两个文件：\n\n1. firebase.json\n2. .firebaserc\n\n我们主要关心 [`firebase.json`](https://firebase.google.com/docs/hosting/full-config)，这里面可以做很多事情，比如设置静态资源的缓存时间：\n\n```json\n{\n  \"hosting\": {\n    \"public\": \"dist\",\n    \"ignore\": [\"firebase.json\", \"**/.*\", \"**/node_modules/**\"],\n    \"headers\": [\n      {\n        \"source\": \"**/*.@(jpg|jpeg|gif|png|svg|ico)\",\n        \"headers\": [\n          {\n            \"key\": \"Cache-Control\",\n            \"value\": \"no-cache\"\n          }\n        ]\n      },\n      {\n        \"source\": \"**/*.@(js|css)\",\n        \"headers\": [\n          {\n            \"key\": \"Cache-Control\",\n            \"value\": \"max-age=31536000\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n## 预览\n\n在部署之前，我们可以执行 `firebase serve` 预览一下，省得部署后才发现有问题：\n\n```bash\n$ firebase serve\n\n=== Serving from '/Users/sam/Documents/githubRepos/blog.zfanw.com'...\n\ni  hosting: Serving hosting files from: dist\n✔  hosting: Local server: http://localhost:5000\n```\n\n## 部署\n\n接下来就可以部署：\n\n```bash\n$ firebase deploy --only hosting\n```\n\n## 自定义域名\n\n部署完成后，我们就能在 `<Project-ID>.firebaseapp.com` 这样一个网址访问到博客，接下来就是[关联我们的自定义域名](https://firebase.google.com/docs/hosting/custom-domain?hl=zh-cn)。`Hosting` 面板下有相应操作指南，这里就略过不提。\n\n不过，配置完自定义域名后，我们会有两个网址：\n\n1. `<Project-ID>.firebaseapp.com`\n2. `你的自定义域名.com`\n\n前者是关不掉的。这是一个问题，因为搜索引擎会从两个网址抓取到一样的内容，对 SEO 来讲，这非常糟糕，搜索引擎可能会判断为内容抄袭、重复，导致你的自定义域名被降权。所以最好使用 [rel=canonical](https://support.google.com/webmasters/answer/139066?hl=zh-Hant) 之类的方案给搜索引擎一个说明。\n\n比如我的博客首页 HTML 代码中会有这样一行：\n\n```html\n<link rel=\"canonical\" href=\"https://blog.zfanw.com/\"/>\n```\n## 体验\n\n快，比托管在 VPS 上确实快得多。\n","isEmpty":false,"excerpt":"","stats":{"ctimeMs":1546997551055.8628},"author":"陈三","description":"","datePublished":1532908800000,"template":"post.js"},{"filePath":"_posts/firefox-13.md","title":"Firefox 13","date":"2012-06-03T14:50:14.000Z","permalink":"/firefox-13/","tags":["Firefox","新闻"],"content":"{:toc}\nMozilla 现在每 6 周推一个新版本 Firefox，最初这些新版本会更新在 ftp 上，然后再推送到其他频道。\n\nFirefox 13 将于 2012.6.5 正式发布。\n\n此次做出的主要变化有：\n\n1. 新主页 (about:home)\n    主页中心部分是浏览器默认的搜索引擎搜索框，另外原来需要通过菜单管理的许多内容现在都可以通过新的主页管理，比如下载、书签、历史记录、扩展、同步、设置。\n2. 新的新建标签页 (about:newtab)\n    快速拨号页面，可以设定一些你经常访问的网站，如果你用过 Opera 或 Google Chrome 的新标签页，相信不会觉得生疏。\n3. 重置 Firefox\n    可以创建新的 Profile（设定档），然后迁移你的书签、密码、cookies 与表单数据到新设定档，其他内容将重置为默认值。这样你就有了全新安装的 Firefox 但又不丢失任何已有数据。相当便捷。\n4. 其他一些小变化，比如性能上的改进啦（这是必需的），还有页面滚动的平滑，等等。\n\nVia [http://www.mozilla.org/en-US/firefox/13.0/releasenotes/](http://www.mozilla.org/en-US/firefox/13.0/releasenotes/)","isEmpty":false,"excerpt":"","stats":{"ctimeMs":1546997551063.0854},"author":"陈三","description":"","datePublished":1338735014000,"dateModified":1338735014000,"template":"post.js"},{"filePath":"_posts/firefox-19.md","title":"firefox 19","date":"2013-02-26T11:23:28.000Z","permalink":"/firefox-19/","tags":["Firefox","新闻"],"content":"{:toc}\nfirefox 19 于 2013.2.19 正式释出。\n\n这个版本开始默认启用内置 PDF 阅读器，用户可直接在 firefox 打开 PDF 文件，不需要安装其他插件。\n\n另外，这个内置 PDF 阅读器还可以使用翻页快捷键：\n\n| 按键  | 功能  |\n| --- | --- |\n| j/n | 下一页 |\n| k/p | 上一页 |\n\n如果只是简单的 PDF 阅读需求，firefox 19 一般已经足够。\n\nVia firefox 19 [release notes](http://www.mozilla.org/en-US/firefox/19.0/releasenotes/)","isEmpty":false,"excerpt":"","stats":{"ctimeMs":1546997551063.224},"author":"陈三","description":"","datePublished":1361877808000,"dateModified":1361877808000,"template":"post.js"},{"filePath":"_posts/firefox-22-new-cookies-policy.md","title":"Firefox 22 引入新 Cookies 政策","date":"2013-02-27T05:30:03.000Z","permalink":"/firefox-22-new-cookies-policy/","tags":["Firefox","新闻"],"content":"{:toc}\nFirefox 22 版本中将引入新的 Cookies 政策。\n\n简单说，第三方 Cookies 将被 Firefox 阻拦，只有用户直接过的网站 Cookies 才被允许。\n\n目前 Google Chrome 默认允许所有 Cookies，作为一个主要靠广告收入的公司，这可以解释；IE 则部分阻拦；而 Safari 很早就不允许第三方网站设置 Cookies。\n\nVia [The New Firefox Cookie Policy](http://webpolicy.org/2013/02/22/the-new-firefox-cookie-policy/#firefox-cookie-policy-fnref:1)","isEmpty":false,"excerpt":"","stats":{"ctimeMs":1546997551063.3433},"author":"陈三","description":"","datePublished":1361943003000,"dateModified":1361943003000,"template":"post.js"},{"filePath":"_posts/firefox-new-ui-more-uniform.md","title":"Firefox 将统一各平台上的 UI","date":"2012-05-03T08:07:35.000Z","permalink":"/firefox-new-ui-more-uniform/","tags":["Firefox","新闻"],"content":"{:toc}\nFirefox 将统一各平台上的 UI，包括桌面、平板、手机与 Windows 8 Metro。\n\n其中桌面版 Firefox 的变化将很大，Windows 系统下桌面版 Firefox 左上角的橘黄色菜单将被剔除，该菜单在 Firefox 4 那次 UI 大改动中出现，至今已存活超过一年。\n\ntab 标签形状也将变得平滑，更具流体感，而非现在的方块状；菜单则集中到地址栏右侧，如果对比 Google Chrome 的 UI，你会发现， Firefox 的 UI 会越来越像 Google Chrome。另外，手机版的 Firefox 中将集成阅读模式。","isEmpty":false,"excerpt":"","stats":{"ctimeMs":1546997551063.4487},"author":"陈三","description":"","datePublished":1336032455000,"dateModified":1336032455000,"template":"post.js"},{"filePath":"_posts/firefox-os/firefox-os.md","title":"Firefox OS 的神奇之处","date":"2012-09-16T13:50:33.000Z","permalink":"/firefox-os/","tags":["Firefox OS","翻译"],"content":"{:toc}\n\n> 本文译自 [There is something magical about firefox OS](http://rawkes.com/articles/there-is-something-magical-about-firefox-os)\n\n过去的一年半时间里，我投入了越来越多的时间在 Mozilla 最新项目 Firefox OS 上。也就在那段时间里，我爱上这个项目，以及它所主张的。这种体验我以前从未体验。\n\n![Firefox OS screenshots](robhawkes_cc-by-sa.jpg)\n\n让我说得再明白点：Firefox OS 只是冰山一角。它是一个即将发生的革命。它让人耳目一新。它是前沿科技的巅峰。它是神奇的，它将改变一切。\n\n## Firefox OS 是什么\n\n对不清楚我在讲什么的人们，我快速介绍一下：\n\n> Firefox OS 是一个 Mozilla Boot to Gecko (B2G) 项目开发的新一代手机操作系统。它使用 Linux 内核，并启动基于 Gecko 的运行时引擎，该引擎允许用户运行完全基于 HTML，JavaScript 及其他开放的 Web 应用 APIs 开发的程序。\n>\n> —[Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Mozilla/Firefox_OS)\n\n简单说，Firefox OS 运用了 Web 背后的技术，比如 JavaScript 来开发一个完整的手机操作系统。花点时间消化一下 – 它是个由 JavaScipt 驱动的手机系统！\n\n为此，一个稍微定制过的 Gecko (Firefox 背后的引擎) 被开发出来，引入[新的 JavScript APIs](https://wiki.mozilla.org/WebAPI#APIs)，以创造接近手机的体验。这包括 WebTelephony，用于拨打电话；WebSMS，用于发送信息；以及振动 API，显然，用于振动。\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/5MzuGWFIfio\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen></iframe>\n\n但是 Firefox OS 又不仅仅只是一些前端科技的疯狂应用，它同时也将 Mozilla 的其他项目统一到一个到作为平台的 Web。这些其他项目包括我们的 [Open Web Aps initiative](https://developer.mozilla.org/en-US/docs/Apps) 及确认身份及登入 Web 的 [Persona](https://developer.mozilla.org/en-US/docs/Archive/Mozilla/Persona)，早期称为 BrowserID。能看到 Mozilla 的这许多不同项目统一到一个平台下绝对是让人着迷的。\n\n更多细节在这儿我就略过不说，毕竟这一篇并非要解释该项目的详细内容，不过更多细节可以在 MDN 的 [Firefox OS 页面](https://developer.mozilla.org/en-US/docs/Mozilla/Firefox_OS)找到。我强烈建议大家阅读它们。\n\n## 为什么要 Firefox OS\n\n你可能在想，“这听起来不错，可为什么要用 JavaScript 来开发手机呢？“你是对的，这是个非常重要的问题。幸运的是，我们已经有许多答案来解释为什么这是个好主意。\n\n两个主要的原因是，Firefox OS 填补了移动市场上的空白，另外它给当前的专利保护、限制性的手机环境提供另一种选择。\n\n### 填补移动市场上的空白\n\n对很多人来说，智能手机多数出奇地贵，哪怕是在那些被认为高收入水平的地区，人们也不觉得它们便宜。但如果你认为它们只是在那些有足够可支配收入支付它们的国家显贵的话，则请想一下，16GB 的 iPhone 4S 在发展中国家如巴西要价相当于 615 英磅，这要比同样的手机在英国的价格贵出 100 英磅。\n\n在巴西，这些飞涨的价格主要是因为高额进口税。苹果公司显然正在通过在该国建立本地生产线来避免这些，但不管怎么说，这都说明一个重要的问题，就是高端设备在全球所有地区并不总是个可选项。更不用说，在某些如[巴西这种犯罪率奇高的国家](http://en.wikipedia.org/wiki/Crime_in_Brazil)，你手里挥舞的一台手机价格相当于一辆小型汽车时会发生什么。\n\n那么，如果你想拥有一部智能手机，又不想支付一大笔钱时该怎样？你可以买台便宜的 Android 手机，不过它们多数表现糟糕。\n\n幸运的是，Firefox OS 来填补空白了…\n\n> Firefox 的目的不是要与高端机竞争，它是要在合适的价格上提供入门到中端级别的智能手机。\n>\n> —[Bonnie Cha](http://allthingsd.com/20120906/mozilla-makes-a-mobile-web-browser-feel-like-a-smartphone)\n\nFirefox OS 非常完美地填补了这个市场空白。它在廉价、低端的硬件上提供可以与 Android 中端水平硬件相媲美的智能机体验。这并非玩笑。\n\n举个例子，我现在在测试 JavaScript 游戏的 Firefox OS 设备值 50 英磅 （可以说，非常低端的一个手机）。你可能会觉得它应该运行得很糟糕，但实际上，它不仅比运行在同一设备上的 Android 浏览器（Firefox 或 Chrome）要快，甚至能跟价格是它的 4-5 倍多的更好设备里运行的情况一样好。\n\n为什么在同样的设备上，跟 Android 的浏览器相比，它会有如此巨大的性能改进？这是因为 Gecko 与硬件之间没有太多东西，这意味着像 JavaScript 这样的可以全速运行。过去就是因为塞太多才导致 JavaScipt 跑得那么慢！\n\n这低廉设备上 JavaScript 的性能表现促使我相信， Firefox OS 意味着某些大事件要开始了。\n\n**我要特别说明一下，Mozilla 不一定要发布一个价值 50 英磅的设备，这只是目前我们用于开发与测试的一个。**\n\n### 提供一个可选的，开放平台\n\n“为什么要 Firefox OS“ 的第二个理由是，它不仅尝试提供一个开放的可选移动平台，也同时挺身而出，希望影响那些强大的闭源移动手机系统玩家做出改变。\n\n> Mozilla 自它 1998 年开始，最初是一个软件项目，之后作为一个基金会及公司，它的使命一直都是提供开放技术，挑战市场支配者的产品。\n>\n> —[Steve Lohr](https://bits.blogs.nytimes.com/2012/02/23/why-mozilla-is-entering-the-smartphone-war/)\n\nMozilla 希望复制它在 Firefox 上的成功，Firefox 冲击了浏览器市场，告诉了用户，他们可以别有选择 - 一个让他们掌控如何使用 Web 的选择。\n\n> 这一次，被威胁的是移动互联网，但不是微软干的，而是苹果及 Google 公司，两个主要的智能手机平台。它们的原生 apps，封闭平台，专有软件商店，以及反复无常的开发者规则，正在使得 Web 技术变得无足轻重。\n>\n> —Thomas Claburn\n\n在手机上，一个亟需改进的是应用的可移植性…\n\n> 除开移动 apps 让人激动的方面外，他们在某一方面来看是在退步：它们将用户捆绑到某一个支持它们的操作系统及设备上。Web 则相反，它允许在任何硬件上得到近似的体验。\n>\n> Mozilla，Firefox web 浏览器的创造者，正决定为智能手机做同样的事。\n>\n> —[Don Clark](https://blogs.wsj.com/digits/2012/09/06/backers-tout-firefox-os-as-open-mobile-option/)\n\nFirefox OS 希望利用 Web 天生的跨平台性来提供一个平台，允许应用可以在移动设备，桌面电脑，平板电脑，又或其他任何可以访问到浏览器的地方使用。你想不想在你的手机上继续玩你电脑上玩的《愤怒的小鸟》游戏？我是非常想的！\n\n### 开发者的黑客梦\n\n最后一个，为什么需要 Firefox OS 的原因是，目前我们还不真正有一个可骇的移动平台（你可以某种程度上地自定义 Android，但它并不容易）。\n\n因为 Firefox OS 基于 HTML，JavaScript 和 CSS，这意味着只要你有基本的 Web 开发技能，就可以开动修改设备体验了。你可以改一行 CSS，然后完全改变桌面上的图标样子，又或者重写一些处理拨打电话功能的核心 JavaScript 文件。\n\n这是一个为开发者打造的平台，我也非常期待，想知道开发者他们能把它带到哪儿。\n\n## 绝佳的时机\n\n在我在 Mozilla 的一年半时间里，我一直觉得我非常幸运，因为一来就赶上 Firefox OS 项目的开始。如果我没有记错，那是我开始这份工作后几周内在内部宣布的这个项目（当时叫 Boot to Gecko）。\n\n当时事情就非常让人兴奋，而现在随着时间它们变得更加有意思了。Firefox OS 可以说是我当时第一个接触的工作内容，老实说我爱它，我也非常荣幸能成为其中一份。\n\n很经常地，我都在想，Firefox 开始发布时，在 Mozilla 工作的人们是不是也是这样的感受，兴奋，激情，紧张，然后又无法解释它怎样地惊人以及人们为什么应该关注它。\n\n老实说，我不认为很多人会真正明白 Firefox OS 所带来的变化，以及为什么它真的重要，但这一切都会改变，等到它发布的时候。就有点像 Firefox，我想。\n\n至于现在，我非常高兴自己在 Mozilla 的时间线上的一个有意思的时间点里加入进来。\n\n## 炸开大脑\n\n目前能理解它的，是那些偶然跟着 Mozillian 参加会议的开发者们，他们有亲手操作过 demo 设备。对我来说，最让我享受的，是看着他们在摆弄手机时情绪所经历的不同变化…\n\n1. 刚开始总是很迷茫 – 一种“呃你给我个 Android 手机搞什么”的表情\n2. 然后突然地意识到这不是 Android，这是用 JavaScript 开发的\n3. 再不一会儿，兴奋劲开始了，类似于“我操”这样的心理感受\n4. 再久一点，他们就非常集中精神了，摸索设备的方方面面，问许多问题\n5. 最后，在我要求还回设备时多少有些不太情愿，但在交还时他们说，“这一点不会差，真的惊到我了！”。\n\n你可能觉得我粉饰过这些以让事情看起来更加美好与惊人，但我只是真实地描绘人们在我展示设备给他们时的反应。真的很好玩。\n\n我越多见别人在 Firefox OS 设备上玩我越确信，这是一个真正的游戏改变者。它看起来就是那种要炸开大脑的，基本不需要我解释什么。\n\n## 许多挑战\n\n如果光谈 Firefox 的好处及我所做的事，而不聊聊一些我们需要解决的挑战，那就显得不太公正。\n\n一方面，我们有很多的常见问题，比如如何管理一个开放而无限制的 apps 生态系统，又或者是可能带来的类似于 Android 上的设备碎片情况。这些都是重要的问题，不过对我来说一点也没兴趣。\n\n我最感兴趣的是移动设备上 HTML5 游戏所带来的挑战 – 可预见的及开发者经常抱怨的真正的性能问题。这决非 Firefox OS 仅有的问题（Android 与 iOS 也一样糟糕），不过现在我主要是关注 Firefox OS 以及怎样我们才能改进它。\n\n照目前来看，大部分已有的 HTML5 手机游戏要么跑得很糟糕（0-20FPS），要么跑得恰恰好（20-30FPS）。大部分时候，这些游戏都不会稳定地跑在某一帧速率上，这就导致体验不是那么好。\n\n有趣的是，大部分的这类问题似乎与设备或 JavaScript 无关。有些 intense 游戏，比如 [Biolab Disaster](http://playbiolab.com/)，即便在我所测试的 50 英磅低端机上也跑得非常不错，我们说的是 40 到 60FPS。\n\n对我来说，这很清楚，虽然某些时候，应该指责一下设备与平台，我们也可以从那些低端机上表现不错的游戏中学习它们所应用的技术，以及如何更好地教导其他打算在手机设备上开发 HTML5 的开发者们。\n\n我真心相信，即使是高精度游戏也可以在手机设备上跑得很好，哪怕是低端设备。为什么我如此自信？因为人们现在已经在制作这些游戏了。有两件东西，是我一生中最信任的…眼睛。\n\n我们会到那儿的。\n\n## 超越移动手机\n\nFirefox OS 让我最激动的其实与明年我们将要发布的手机无关，而是在于它所把握的未来。在之前谈 Firefox 如何成为一个 hackable 梦想乐园时我说过，即其他人会怎样运用它并将其带出 Mozilla 所不能预见之地。\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/rk1oTO6cYH0\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen></iframe>\n\n好消息是，这些在今天正在发生着。我们已经有 [Firefox OS for Raspberry Pi](https://www.youtube.com/watch?v=rk1oTO6cYH0) 的移植版，以及一个 [Pandaboard 的移植版](https://developer.mozilla.org/en-US/docs/Mozilla/Boot_to_Gecko/Pandaboard)。它们不完美，但妙在（抱歉，我已经很努力地避免用这个词了）这全部发生在 Firefox OS 的首次发布之前。\n\n你也可以通过一个桌面客户端在 Mac，Windows 和 Linux 上运行 Firefox OS。虽然不能给你与在手机上一样的硬件访问能力，桌面客户端允许你利用一些其他 OS 的特性，而且设置简单。\n\n我甚至可以想像，在不久后的一天，Gamepad API 在 Gecko 上出现，然后可以通过 Firefox OS 桌面客户端访问到。有什么酷的地方吗？好吧，并非我异想天开的是，我们可能看到桌面客户端运行在一个设备上，设备联接到 TV，然后跑的系统是定制的 OS，可以使用 gamepad 输入替换鼠标与触摸（记住，这全部只是 JavaScript）。\n\n你将会有的，是一个 HTML5 游戏控制台的开始，实际上，这也是我在 Mozilla 上的业余时间里积极探索的。\n\n我的观点是，我们已经到了这个点上，移动设备完全可以由那些建设网站的同样的技术来驱动。在一个满是这些技术驱动的，可以通过相同 APIs 访问、交流的设备的世界里我们能做什么？\n\n我真是太紧切想看看这样的世界是怎么个样子！\n","isEmpty":false,"excerpt":"","stats":{"ctimeMs":1546997551063.7483},"author":"陈三","description":"","datePublished":1347803433000,"dateModified":1347803433000,"template":"post.js"},{"filePath":"_posts/github-pages-custom-domain/github-pages-custom-domain.md","title":"Github Pages 自定义域名","date":"2014-11-11T05:27:43.000Z","permalink":"/github-pages-custom-domain/","tags":["Github"],"content":"{:toc}\n\n如果你需要存放网页，但没有自己的服务器，那么 Github Pages 是个不错的托管选择。\n\n拿我的 Github 账户说，我的账户名是 chenxsan，则 `chenxsan.github.io` 是 Github 保留给我的域名：\n\n1. 创建一个名称为 `chenxsan.github.io` 的仓库，\n2. 推送本地文件到仓库，\n3. 开启仓库设置中的 GitHub Pages，\n4. 访问 `chenxsan.github.io` - 服务器、域名的费用都省了。\n\n不过我决定给它自定义一个域名，比如 `example.zfanw.com`。\n\n## 设置自定义域名\n\n首先我们需要在仓库的设置里填入自定义域名，如下图：\n\n![Github pages custom domain](./github-pages-custom-domain.png)\n\n此时访问 example.zfanw.com，浏览器会提示：\n\n```\nexample.zfanw.com’s server IP address could not be found.\n```\n\nIP 地址未找到 - 因为我们还没做任何 DNS 解析的工作。\n\n## 绑定 CNAME\n\n一般情况下，我们是添加 A 记录将域名指向 IP。但 Github Pages 是通过 [`CNAME`](https://en.wikipedia.org/wiki/CNAME_record) 绑定的 - CNAME 指 Canonical Name record，其实就是域名的别名。\n\n在 DNS 管理中添加一条 `CNAME` 记录，将 `example` 子域名指向 `chenxsan.github.io`，随后用 `dig` 命令来查看 DNS 解析情况：\n\n```bash\n$ dig example.zfanw.com +nostats +nocomments +nocmd\n\n; <<>> DiG 9.9.7-P3 <<>> example.zfanw.com +nostats +nocomments +nocmd\n;; global options: +cmd\n;example.zfanw.com.             IN      A\nexample.zfanw.com.      3599    IN      CNAME   chenxsan.github.io.\nchenxsan.github.io.     3599    IN      CNAME   sni.github.map.fastly.net.\nsni.github.map.fastly.net. 18   IN      A       151.101.53.147\n```\n成功。\n\n就这么简单？是的，就这么简单 - 不过你如果要配置顶级域名的话，则稍稍复杂些，请查阅 [Github 文档](https://help.github.com/articles/setting-up-an-apex-domain/)。\n\n## 不足之处\n\n目前 Github Pages 的自定义域名不支持 https。\n\n## 更新\n\n2018.05.01 开始，Github Pages 自定义域名[支持 https](https://blog.github.com/2018-05-01-github-pages-custom-domains-https/)。","isEmpty":false,"excerpt":"","stats":{"ctimeMs":1546997551064.6074},"author":"陈三","description":"","datePublished":1415683663000,"dateModified":1415683663000,"template":"post.js"}]}